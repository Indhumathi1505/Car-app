import { t as __commonJS } from "./chunk-DUEDWNxO.js";

//#region node_modules/sockjs-client/lib/utils/browser-crypto.js
var require_browser_crypto = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/browser-crypto.js": ((exports, module) => {
	if (global.crypto && global.crypto.getRandomValues) module.exports.randomBytes = function(length) {
		var bytes = new Uint8Array(length);
		global.crypto.getRandomValues(bytes);
		return bytes;
	};
	else module.exports.randomBytes = function(length) {
		var bytes = new Array(length);
		for (var i = 0; i < length; i++) bytes[i] = Math.floor(Math.random() * 256);
		return bytes;
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/random.js
var require_random = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/random.js": ((exports, module) => {
	var crypto = require_browser_crypto();
	var _randomStringChars = "abcdefghijklmnopqrstuvwxyz012345";
	module.exports = {
		string: function(length) {
			var max = _randomStringChars.length;
			var bytes = crypto.randomBytes(length);
			var ret = [];
			for (var i = 0; i < length; i++) ret.push(_randomStringChars.substr(bytes[i] % max, 1));
			return ret.join("");
		},
		number: function(max) {
			return Math.floor(Math.random() * max);
		},
		numberString: function(max) {
			var t = ("" + (max - 1)).length;
			return (new Array(t + 1).join("0") + this.number(max)).slice(-t);
		}
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/event.js
var require_event$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/event.js": ((exports, module) => {
	var random$5 = require_random();
	var onUnload = {}, afterUnload = false, isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime;
	module.exports = {
		attachEvent: function(event, listener) {
			if (typeof global.addEventListener !== "undefined") global.addEventListener(event, listener, false);
			else if (global.document && global.attachEvent) {
				global.document.attachEvent("on" + event, listener);
				global.attachEvent("on" + event, listener);
			}
		},
		detachEvent: function(event, listener) {
			if (typeof global.addEventListener !== "undefined") global.removeEventListener(event, listener, false);
			else if (global.document && global.detachEvent) {
				global.document.detachEvent("on" + event, listener);
				global.detachEvent("on" + event, listener);
			}
		},
		unloadAdd: function(listener) {
			if (isChromePackagedApp) return null;
			var ref = random$5.string(8);
			onUnload[ref] = listener;
			if (afterUnload) setTimeout(this.triggerUnloadCallbacks, 0);
			return ref;
		},
		unloadDel: function(ref) {
			if (ref in onUnload) delete onUnload[ref];
		},
		triggerUnloadCallbacks: function() {
			for (var ref in onUnload) {
				onUnload[ref]();
				delete onUnload[ref];
			}
		}
	};
	var unloadTriggered = function() {
		if (afterUnload) return;
		afterUnload = true;
		module.exports.triggerUnloadCallbacks();
	};
	if (!isChromePackagedApp) module.exports.attachEvent("unload", unloadTriggered);
}) });

//#endregion
//#region node_modules/requires-port/index.js
var require_requires_port = /* @__PURE__ */ __commonJS({ "node_modules/requires-port/index.js": ((exports, module) => {
	/**
	* Check if we're required to add a port number.
	*
	* @see https://url.spec.whatwg.org/#default-port
	* @param {Number|String} port Port number we need to check
	* @param {String} protocol Protocol we need to check against.
	* @returns {Boolean} Is it a default port for the given protocol
	* @api private
	*/
	module.exports = function required$1(port$1, protocol) {
		protocol = protocol.split(":")[0];
		port$1 = +port$1;
		if (!port$1) return false;
		switch (protocol) {
			case "http":
			case "ws": return port$1 !== 80;
			case "https":
			case "wss": return port$1 !== 443;
			case "ftp": return port$1 !== 21;
			case "gopher": return port$1 !== 70;
			case "file": return false;
		}
		return port$1 !== 0;
	};
}) });

//#endregion
//#region node_modules/querystringify/index.js
var require_querystringify = /* @__PURE__ */ __commonJS({ "node_modules/querystringify/index.js": ((exports) => {
	var has = Object.prototype.hasOwnProperty, undef;
	/**
	* Decode a URI encoded string.
	*
	* @param {String} input The URI encoded string.
	* @returns {String|Null} The decoded string.
	* @api private
	*/
	function decode(input) {
		try {
			return decodeURIComponent(input.replace(/\+/g, " "));
		} catch (e) {
			return null;
		}
	}
	/**
	* Attempts to encode a given input.
	*
	* @param {String} input The string that needs to be encoded.
	* @returns {String|Null} The encoded string.
	* @api private
	*/
	function encode(input) {
		try {
			return encodeURIComponent(input);
		} catch (e) {
			return null;
		}
	}
	/**
	* Simple query string parser.
	*
	* @param {String} query The query string that needs to be parsed.
	* @returns {Object}
	* @api public
	*/
	function querystring(query) {
		var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
		while (part = parser.exec(query)) {
			var key = decode(part[1]), value = decode(part[2]);
			if (key === null || value === null || key in result) continue;
			result[key] = value;
		}
		return result;
	}
	/**
	* Transform a query string to an object.
	*
	* @param {Object} obj Object that should be transformed.
	* @param {String} prefix Optional prefix.
	* @returns {String}
	* @api public
	*/
	function querystringify(obj, prefix) {
		prefix = prefix || "";
		var pairs = [], value, key;
		if ("string" !== typeof prefix) prefix = "?";
		for (key in obj) if (has.call(obj, key)) {
			value = obj[key];
			if (!value && (value === null || value === undef || isNaN(value))) value = "";
			key = encode(key);
			value = encode(value);
			if (key === null || value === null) continue;
			pairs.push(key + "=" + value);
		}
		return pairs.length ? prefix + pairs.join("&") : "";
	}
	exports.stringify = querystringify;
	exports.parse = querystring;
}) });

//#endregion
//#region node_modules/url-parse/index.js
var require_url_parse = /* @__PURE__ */ __commonJS({ "node_modules/url-parse/index.js": ((exports, module) => {
	var required = require_requires_port(), qs = require_querystringify(), controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, CRHTLF = /[\n\r\t]/g, slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//, port = /:\d+$/, protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i, windowsDriveLetter = /^[a-zA-Z]:/;
	/**
	* Remove control characters and whitespace from the beginning of a string.
	*
	* @param {Object|String} str String to trim.
	* @returns {String} A new string representing `str` stripped of control
	*     characters and whitespace from its beginning.
	* @public
	*/
	function trimLeft(str) {
		return (str ? str : "").toString().replace(controlOrWhitespace, "");
	}
	/**
	* These are the parse rules for the URL parser, it informs the parser
	* about:
	*
	* 0. The char it Needs to parse, if it's a string it should be done using
	*    indexOf, RegExp using exec and NaN means set as current value.
	* 1. The property we should set when parsing this value.
	* 2. Indication if it's backwards or forward parsing, when set as number it's
	*    the value of extra chars that should be split off.
	* 3. Inherit from location if non existing in the parser.
	* 4. `toLowerCase` the resulting value.
	*/
	var rules = [
		["#", "hash"],
		["?", "query"],
		function sanitize(address, url) {
			return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
		},
		["/", "pathname"],
		[
			"@",
			"auth",
			1
		],
		[
			NaN,
			"host",
			void 0,
			1,
			1
		],
		[
			/:(\d*)$/,
			"port",
			void 0,
			1
		],
		[
			NaN,
			"hostname",
			void 0,
			1,
			1
		]
	];
	/**
	* These properties should not be copied or inherited from. This is only needed
	* for all non blob URL's as a blob URL does not include a hash, only the
	* origin.
	*
	* @type {Object}
	* @private
	*/
	var ignore = {
		hash: 1,
		query: 1
	};
	/**
	* The location object differs when your code is loaded through a normal page,
	* Worker or through a worker using a blob. And with the blobble begins the
	* trouble as the location object will contain the URL of the blob, not the
	* location of the page where our code is loaded in. The actual origin is
	* encoded in the `pathname` so we can thankfully generate a good "default"
	* location from it so we can generate proper relative URL's again.
	*
	* @param {Object|String} loc Optional default location object.
	* @returns {Object} lolcation object.
	* @public
	*/
	function lolcation(loc$2) {
		var globalVar;
		if (typeof window !== "undefined") globalVar = window;
		else if (typeof global !== "undefined") globalVar = global;
		else if (typeof self !== "undefined") globalVar = self;
		else globalVar = {};
		var location = globalVar.location || {};
		loc$2 = loc$2 || location;
		var finaldestination = {}, type = typeof loc$2, key;
		if ("blob:" === loc$2.protocol) finaldestination = new Url(unescape(loc$2.pathname), {});
		else if ("string" === type) {
			finaldestination = new Url(loc$2, {});
			for (key in ignore) delete finaldestination[key];
		} else if ("object" === type) {
			for (key in loc$2) {
				if (key in ignore) continue;
				finaldestination[key] = loc$2[key];
			}
			if (finaldestination.slashes === void 0) finaldestination.slashes = slashes.test(loc$2.href);
		}
		return finaldestination;
	}
	/**
	* Check whether a protocol scheme is special.
	*
	* @param {String} The protocol scheme of the URL
	* @return {Boolean} `true` if the protocol scheme is special, else `false`
	* @private
	*/
	function isSpecial(scheme) {
		return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
	}
	/**
	* @typedef ProtocolExtract
	* @type Object
	* @property {String} protocol Protocol matched in the URL, in lowercase.
	* @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
	* @property {String} rest Rest of the URL that is not part of the protocol.
	*/
	/**
	* Extract protocol information from a URL with/without double slash ("//").
	*
	* @param {String} address URL we want to extract from.
	* @param {Object} location
	* @return {ProtocolExtract} Extracted information.
	* @private
	*/
	function extractProtocol(address, location) {
		address = trimLeft(address);
		address = address.replace(CRHTLF, "");
		location = location || {};
		var match = protocolre.exec(address);
		var protocol = match[1] ? match[1].toLowerCase() : "";
		var forwardSlashes = !!match[2];
		var otherSlashes = !!match[3];
		var slashesCount = 0;
		var rest;
		if (forwardSlashes) if (otherSlashes) {
			rest = match[2] + match[3] + match[4];
			slashesCount = match[2].length + match[3].length;
		} else {
			rest = match[2] + match[4];
			slashesCount = match[2].length;
		}
		else if (otherSlashes) {
			rest = match[3] + match[4];
			slashesCount = match[3].length;
		} else rest = match[4];
		if (protocol === "file:") {
			if (slashesCount >= 2) rest = rest.slice(2);
		} else if (isSpecial(protocol)) rest = match[4];
		else if (protocol) {
			if (forwardSlashes) rest = rest.slice(2);
		} else if (slashesCount >= 2 && isSpecial(location.protocol)) rest = match[4];
		return {
			protocol,
			slashes: forwardSlashes || isSpecial(protocol),
			slashesCount,
			rest
		};
	}
	/**
	* Resolve a relative URL pathname against a base URL pathname.
	*
	* @param {String} relative Pathname of the relative URL.
	* @param {String} base Pathname of the base URL.
	* @return {String} Resolved pathname.
	* @private
	*/
	function resolve(relative, base) {
		if (relative === "") return base;
		var path = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path.length, last = path[i - 1], unshift = false, up = 0;
		while (i--) if (path[i] === ".") path.splice(i, 1);
		else if (path[i] === "..") {
			path.splice(i, 1);
			up++;
		} else if (up) {
			if (i === 0) unshift = true;
			path.splice(i, 1);
			up--;
		}
		if (unshift) path.unshift("");
		if (last === "." || last === "..") path.push("");
		return path.join("/");
	}
	/**
	* The actual URL instance. Instead of returning an object we've opted-in to
	* create an actual constructor as it's much more memory efficient and
	* faster and it pleases my OCD.
	*
	* It is worth noting that we should not use `URL` as class name to prevent
	* clashes with the global URL instance that got introduced in browsers.
	*
	* @constructor
	* @param {String} address URL we want to parse.
	* @param {Object|String} [location] Location defaults for relative paths.
	* @param {Boolean|Function} [parser] Parser for the query string.
	* @private
	*/
	function Url(address, location, parser) {
		address = trimLeft(address);
		address = address.replace(CRHTLF, "");
		if (!(this instanceof Url)) return new Url(address, location, parser);
		var relative, extracted, parse$1, instruction, index, key, instructions = rules.slice(), type = typeof location, url = this, i = 0;
		if ("object" !== type && "string" !== type) {
			parser = location;
			location = null;
		}
		if (parser && "function" !== typeof parser) parser = qs.parse;
		location = lolcation(location);
		extracted = extractProtocol(address || "", location);
		relative = !extracted.protocol && !extracted.slashes;
		url.slashes = extracted.slashes || relative && location.slashes;
		url.protocol = extracted.protocol || location.protocol || "";
		address = extracted.rest;
		if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) instructions[3] = [/(.*)/, "pathname"];
		for (; i < instructions.length; i++) {
			instruction = instructions[i];
			if (typeof instruction === "function") {
				address = instruction(address, url);
				continue;
			}
			parse$1 = instruction[0];
			key = instruction[1];
			if (parse$1 !== parse$1) url[key] = address;
			else if ("string" === typeof parse$1) {
				index = parse$1 === "@" ? address.lastIndexOf(parse$1) : address.indexOf(parse$1);
				if (~index) if ("number" === typeof instruction[2]) {
					url[key] = address.slice(0, index);
					address = address.slice(index + instruction[2]);
				} else {
					url[key] = address.slice(index);
					address = address.slice(0, index);
				}
			} else if (index = parse$1.exec(address)) {
				url[key] = index[1];
				address = address.slice(0, index.index);
			}
			url[key] = url[key] || (relative && instruction[3] ? location[key] || "" : "");
			if (instruction[4]) url[key] = url[key].toLowerCase();
		}
		if (parser) url.query = parser(url.query);
		if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) url.pathname = resolve(url.pathname, location.pathname);
		if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) url.pathname = "/" + url.pathname;
		if (!required(url.port, url.protocol)) {
			url.host = url.hostname;
			url.port = "";
		}
		url.username = url.password = "";
		if (url.auth) {
			index = url.auth.indexOf(":");
			if (~index) {
				url.username = url.auth.slice(0, index);
				url.username = encodeURIComponent(decodeURIComponent(url.username));
				url.password = url.auth.slice(index + 1);
				url.password = encodeURIComponent(decodeURIComponent(url.password));
			} else url.username = encodeURIComponent(decodeURIComponent(url.auth));
			url.auth = url.password ? url.username + ":" + url.password : url.username;
		}
		url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
		url.href = url.toString();
	}
	/**
	* This is convenience method for changing properties in the URL instance to
	* insure that they all propagate correctly.
	*
	* @param {String} part          Property we need to adjust.
	* @param {Mixed} value          The newly assigned value.
	* @param {Boolean|Function} fn  When setting the query, it will be the function
	*                               used to parse the query.
	*                               When setting the protocol, double slash will be
	*                               removed from the final url if it is true.
	* @returns {URL} URL instance for chaining.
	* @public
	*/
	function set(part, value, fn) {
		var url = this;
		switch (part) {
			case "query":
				if ("string" === typeof value && value.length) value = (fn || qs.parse)(value);
				url[part] = value;
				break;
			case "port":
				url[part] = value;
				if (!required(value, url.protocol)) {
					url.host = url.hostname;
					url[part] = "";
				} else if (value) url.host = url.hostname + ":" + value;
				break;
			case "hostname":
				url[part] = value;
				if (url.port) value += ":" + url.port;
				url.host = value;
				break;
			case "host":
				url[part] = value;
				if (port.test(value)) {
					value = value.split(":");
					url.port = value.pop();
					url.hostname = value.join(":");
				} else {
					url.hostname = value;
					url.port = "";
				}
				break;
			case "protocol":
				url.protocol = value.toLowerCase();
				url.slashes = !fn;
				break;
			case "pathname":
			case "hash":
				if (value) {
					var char = part === "pathname" ? "/" : "#";
					url[part] = value.charAt(0) !== char ? char + value : value;
				} else url[part] = value;
				break;
			case "username":
			case "password":
				url[part] = encodeURIComponent(value);
				break;
			case "auth":
				var index = value.indexOf(":");
				if (~index) {
					url.username = value.slice(0, index);
					url.username = encodeURIComponent(decodeURIComponent(url.username));
					url.password = value.slice(index + 1);
					url.password = encodeURIComponent(decodeURIComponent(url.password));
				} else url.username = encodeURIComponent(decodeURIComponent(value));
		}
		for (var i = 0; i < rules.length; i++) {
			var ins = rules[i];
			if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
		}
		url.auth = url.password ? url.username + ":" + url.password : url.username;
		url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
		url.href = url.toString();
		return url;
	}
	/**
	* Transform the properties back in to a valid and full URL string.
	*
	* @param {Function} stringify Optional query stringify function.
	* @returns {String} Compiled version of the URL.
	* @public
	*/
	function toString(stringify) {
		if (!stringify || "function" !== typeof stringify) stringify = qs.stringify;
		var query, url = this, host = url.host, protocol = url.protocol;
		if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
		var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
		if (url.username) {
			result += url.username;
			if (url.password) result += ":" + url.password;
			result += "@";
		} else if (url.password) {
			result += ":" + url.password;
			result += "@";
		} else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") result += "@";
		if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) host += ":";
		result += host + url.pathname;
		query = "object" === typeof url.query ? stringify(url.query) : url.query;
		if (query) result += "?" !== query.charAt(0) ? "?" + query : query;
		if (url.hash) result += url.hash;
		return result;
	}
	Url.prototype = {
		set,
		toString
	};
	Url.extractProtocol = extractProtocol;
	Url.location = lolcation;
	Url.trimLeft = trimLeft;
	Url.qs = qs;
	module.exports = Url;
}) });

//#endregion
//#region node_modules/ms/index.js
var require_ms = /* @__PURE__ */ __commonJS({ "node_modules/ms/index.js": ((exports, module) => {
	/**
	* Helpers.
	*/
	var s = 1e3;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	/**
	* Parse or format the given `val`.
	*
	* Options:
	*
	*  - `long` verbose formatting [false]
	*
	* @param {String|Number} val
	* @param {Object} [options]
	* @throws {Error} throw an error if val is not a non-empty string or a number
	* @return {String|Number}
	* @api public
	*/
	module.exports = function(val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) return parse(val);
		else if (type === "number" && isFinite(val)) return options.long ? fmtLong(val) : fmtShort(val);
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	/**
	* Parse the given `str` and return milliseconds.
	*
	* @param {String} str
	* @return {Number}
	* @api private
	*/
	function parse(str) {
		str = String(str);
		if (str.length > 100) return;
		var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
		if (!match) return;
		var n = parseFloat(match[1]);
		switch ((match[2] || "ms").toLowerCase()) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y": return n * y;
			case "weeks":
			case "week":
			case "w": return n * w;
			case "days":
			case "day":
			case "d": return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h": return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m": return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s": return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms": return n;
			default: return;
		}
	}
	/**
	* Short format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return Math.round(ms / d) + "d";
		if (msAbs >= h) return Math.round(ms / h) + "h";
		if (msAbs >= m) return Math.round(ms / m) + "m";
		if (msAbs >= s) return Math.round(ms / s) + "s";
		return ms + "ms";
	}
	/**
	* Long format for `ms`.
	*
	* @param {Number} ms
	* @return {String}
	* @api private
	*/
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) return plural(ms, msAbs, d, "day");
		if (msAbs >= h) return plural(ms, msAbs, h, "hour");
		if (msAbs >= m) return plural(ms, msAbs, m, "minute");
		if (msAbs >= s) return plural(ms, msAbs, s, "second");
		return ms + " ms";
	}
	/**
	* Pluralization helper.
	*/
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
}) });

//#endregion
//#region node_modules/sockjs-client/node_modules/debug/src/common.js
var require_common = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/node_modules/debug/src/common.js": ((exports, module) => {
	/**
	* This is the common logic for both the Node.js and web browser
	* implementations of `debug()`.
	*/
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		Object.keys(env).forEach(function(key) {
			createDebug[key] = env[key];
		});
		/**
		* Active `debug` instances.
		*/
		createDebug.instances = [];
		/**
		* The currently active debug mode names, and names to skip.
		*/
		createDebug.names = [];
		createDebug.skips = [];
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			var hash = 0;
			for (var i = 0; i < namespace.length; i++) {
				hash = (hash << 5) - hash + namespace.charCodeAt(i);
				hash |= 0;
			}
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			var prevTime;
			function debug$21() {
				if (!debug$21.enabled) return;
				for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
				var self$1 = debug$21;
				var curr = Number(/* @__PURE__ */ new Date());
				self$1.diff = curr - (prevTime || curr);
				self$1.prev = prevTime;
				self$1.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") args.unshift("%O");
				var index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
					if (match === "%%") return match;
					index++;
					var formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						var val = args[index];
						match = formatter.call(self$1, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self$1, args);
				(self$1.log || createDebug.log).apply(self$1, args);
			}
			debug$21.namespace = namespace;
			debug$21.enabled = createDebug.enabled(namespace);
			debug$21.useColors = createDebug.useColors();
			debug$21.color = selectColor(namespace);
			debug$21.destroy = destroy;
			debug$21.extend = extend;
			if (typeof createDebug.init === "function") createDebug.init(debug$21);
			createDebug.instances.push(debug$21);
			return debug$21;
		}
		function destroy() {
			var index = createDebug.instances.indexOf(this);
			if (index !== -1) {
				createDebug.instances.splice(index, 1);
				return true;
			}
			return false;
		}
		function extend(namespace, delimiter) {
			return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
		}
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.names = [];
			createDebug.skips = [];
			var i;
			var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
			var len = split.length;
			for (i = 0; i < len; i++) {
				if (!split[i]) continue;
				namespaces = split[i].replace(/\*/g, ".*?");
				if (namespaces[0] === "-") createDebug.skips.push(/* @__PURE__ */ new RegExp("^" + namespaces.substr(1) + "$"));
				else createDebug.names.push(/* @__PURE__ */ new RegExp("^" + namespaces + "$"));
			}
			for (i = 0; i < createDebug.instances.length; i++) {
				var instance = createDebug.instances[i];
				instance.enabled = createDebug.enabled(instance.namespace);
			}
		}
		/**
		* Disable debug output.
		*
		* @api public
		*/
		function disable() {
			createDebug.enable("");
		}
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === "*") return true;
			var i;
			var len;
			for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return false;
			for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return true;
			return false;
		}
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) return val.stack || val.message;
			return val;
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
}) });

//#endregion
//#region node_modules/sockjs-client/node_modules/debug/src/browser.js
var require_browser$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/node_modules/debug/src/browser.js": ((exports, module) => {
	function _typeof(obj) {
		if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") _typeof = function _typeof$1(obj$1) {
			return typeof obj$1;
		};
		else _typeof = function _typeof$1(obj$1) {
			return obj$1 && typeof Symbol === "function" && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
		};
		return _typeof(obj);
	}
	/**
	* This is the web browser implementation of `debug()`.
	*/
	exports.log = log$1;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	/**
	* Colors.
	*/
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33"
	];
	/**
	* Currently only WebKit-based Web Inspectors, Firefox >= v31,
	* and the Firebug extension (any Firefox version) are known
	* to support "%c" CSS customizations.
	*
	* TODO: add a `localStorage` variable to explicitly enable/disable colors
	*/
	function useColors() {
		if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
		if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
		return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
	}
	/**
	* Colorize log arguments if enabled.
	*
	* @api public
	*/
	function formatArgs(args) {
		args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
		if (!this.useColors) return;
		var c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		var index = 0;
		var lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, function(match) {
			if (match === "%%") return;
			index++;
			if (match === "%c") lastC = index;
		});
		args.splice(lastC, 0, c);
	}
	/**
	* Invokes `console.log()` when available.
	* No-op when `console.log` is not a "function".
	*
	* @api public
	*/
	function log$1() {
		var _console;
		return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
	}
	/**
	* Save `namespaces`.
	*
	* @param {String} namespaces
	* @api private
	*/
	function save(namespaces) {
		try {
			if (namespaces) exports.storage.setItem("debug", namespaces);
			else exports.storage.removeItem("debug");
		} catch (error) {}
	}
	/**
	* Load `namespaces`.
	*
	* @return {String} returns the previously persisted debug modes
	* @api private
	*/
	function load() {
		var r;
		try {
			r = exports.storage.getItem("debug");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) r = process.env.DEBUG;
		return r;
	}
	/**
	* Localstorage attempts to return the localstorage.
	*
	* This is necessary because safari throws
	* when a user disables cookies/localstorage
	* and you attempt to access it.
	*
	* @return {LocalStorage}
	* @api private
	*/
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	var formatters = module.exports.formatters;
	/**
	* Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	*/
	formatters.j = function(v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/url.js
var require_url = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/url.js": ((exports, module) => {
	var URL$1 = require_url_parse();
	var debug$20 = function() {};
	debug$20 = require_browser$1()("sockjs-client:utils:url");
	module.exports = {
		getOrigin: function(url) {
			if (!url) return null;
			var p = new URL$1(url);
			if (p.protocol === "file:") return null;
			var port$1 = p.port;
			if (!port$1) port$1 = p.protocol === "https:" ? "443" : "80";
			return p.protocol + "//" + p.hostname + ":" + port$1;
		},
		isOriginEqual: function(a, b) {
			var res = this.getOrigin(a) === this.getOrigin(b);
			debug$20("same", a, b, res);
			return res;
		},
		isSchemeEqual: function(a, b) {
			return a.split(":")[0] === b.split(":")[0];
		},
		addPath: function(url, path) {
			var qs$1 = url.split("?");
			return qs$1[0] + path + (qs$1[1] ? "?" + qs$1[1] : "");
		},
		addQuery: function(url, q) {
			return url + (url.indexOf("?") === -1 ? "?" + q : "&" + q);
		},
		isLoopbackAddr: function(addr) {
			return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) || /^\[::1\]$/.test(addr);
		}
	};
}) });

//#endregion
//#region node_modules/inherits/inherits_browser.js
var require_inherits_browser = /* @__PURE__ */ __commonJS({ "node_modules/inherits/inherits_browser.js": ((exports, module) => {
	if (typeof Object.create === "function") module.exports = function inherits$31(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			ctor.prototype = Object.create(superCtor.prototype, { constructor: {
				value: ctor,
				enumerable: false,
				writable: true,
				configurable: true
			} });
		}
	};
	else module.exports = function inherits$31(ctor, superCtor) {
		if (superCtor) {
			ctor.super_ = superCtor;
			var TempCtor = function() {};
			TempCtor.prototype = superCtor.prototype;
			ctor.prototype = new TempCtor();
			ctor.prototype.constructor = ctor;
		}
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/event/eventtarget.js
var require_eventtarget = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/event/eventtarget.js": ((exports, module) => {
	function EventTarget$2() {
		this._listeners = {};
	}
	EventTarget$2.prototype.addEventListener = function(eventType, listener) {
		if (!(eventType in this._listeners)) this._listeners[eventType] = [];
		var arr = this._listeners[eventType];
		if (arr.indexOf(listener) === -1) arr = arr.concat([listener]);
		this._listeners[eventType] = arr;
	};
	EventTarget$2.prototype.removeEventListener = function(eventType, listener) {
		var arr = this._listeners[eventType];
		if (!arr) return;
		var idx = arr.indexOf(listener);
		if (idx !== -1) {
			if (arr.length > 1) this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
			else delete this._listeners[eventType];
			return;
		}
	};
	EventTarget$2.prototype.dispatchEvent = function() {
		var event = arguments[0];
		var t = event.type;
		var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
		if (this["on" + t]) this["on" + t].apply(this, args);
		if (t in this._listeners) {
			var listeners = this._listeners[t];
			for (var i = 0; i < listeners.length; i++) listeners[i].apply(this, args);
		}
	};
	module.exports = EventTarget$2;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/event/emitter.js
var require_emitter = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/event/emitter.js": ((exports, module) => {
	var inherits$30 = require_inherits_browser(), EventTarget$1 = require_eventtarget();
	function EventEmitter$15() {
		EventTarget$1.call(this);
	}
	inherits$30(EventEmitter$15, EventTarget$1);
	EventEmitter$15.prototype.removeAllListeners = function(type) {
		if (type) delete this._listeners[type];
		else this._listeners = {};
	};
	EventEmitter$15.prototype.once = function(type, listener) {
		var self$1 = this, fired = false;
		function g() {
			self$1.removeListener(type, g);
			if (!fired) {
				fired = true;
				listener.apply(this, arguments);
			}
		}
		this.on(type, g);
	};
	EventEmitter$15.prototype.emit = function() {
		var type = arguments[0];
		var listeners = this._listeners[type];
		if (!listeners) return;
		var l = arguments.length;
		var args = new Array(l - 1);
		for (var ai = 1; ai < l; ai++) args[ai - 1] = arguments[ai];
		for (var i = 0; i < listeners.length; i++) listeners[i].apply(this, args);
	};
	EventEmitter$15.prototype.on = EventEmitter$15.prototype.addListener = EventTarget$1.prototype.addEventListener;
	EventEmitter$15.prototype.removeListener = EventTarget$1.prototype.removeEventListener;
	module.exports.EventEmitter = EventEmitter$15;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/browser/websocket.js
var require_websocket$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/browser/websocket.js": ((exports, module) => {
	var Driver = global.WebSocket || global.MozWebSocket;
	if (Driver) module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
	else module.exports = void 0;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/websocket.js
var require_websocket = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/websocket.js": ((exports, module) => {
	var utils$3 = require_event$1(), urlUtils$11 = require_url(), inherits$29 = require_inherits_browser(), EventEmitter$14 = require_emitter().EventEmitter, WebsocketDriver = require_websocket$1();
	var debug$19 = function() {};
	debug$19 = require_browser$1()("sockjs-client:websocket");
	function WebSocketTransport(transUrl, ignore$1, options) {
		if (!WebSocketTransport.enabled()) throw new Error("Transport created when disabled");
		EventEmitter$14.call(this);
		debug$19("constructor", transUrl);
		var self$1 = this;
		var url = urlUtils$11.addPath(transUrl, "/websocket");
		if (url.slice(0, 5) === "https") url = "wss" + url.slice(5);
		else url = "ws" + url.slice(4);
		this.url = url;
		this.ws = new WebsocketDriver(this.url, [], options);
		this.ws.onmessage = function(e) {
			debug$19("message event", e.data);
			self$1.emit("message", e.data);
		};
		this.unloadRef = utils$3.unloadAdd(function() {
			debug$19("unload");
			self$1.ws.close();
		});
		this.ws.onclose = function(e) {
			debug$19("close event", e.code, e.reason);
			self$1.emit("close", e.code, e.reason);
			self$1._cleanup();
		};
		this.ws.onerror = function(e) {
			debug$19("error event", e);
			self$1.emit("close", 1006, "WebSocket connection broken");
			self$1._cleanup();
		};
	}
	inherits$29(WebSocketTransport, EventEmitter$14);
	WebSocketTransport.prototype.send = function(data) {
		var msg = "[" + data + "]";
		debug$19("send", msg);
		this.ws.send(msg);
	};
	WebSocketTransport.prototype.close = function() {
		debug$19("close");
		var ws = this.ws;
		this._cleanup();
		if (ws) ws.close();
	};
	WebSocketTransport.prototype._cleanup = function() {
		debug$19("_cleanup");
		var ws = this.ws;
		if (ws) ws.onmessage = ws.onclose = ws.onerror = null;
		utils$3.unloadDel(this.unloadRef);
		this.unloadRef = this.ws = null;
		this.removeAllListeners();
	};
	WebSocketTransport.enabled = function() {
		debug$19("enabled");
		return !!WebsocketDriver;
	};
	WebSocketTransport.transportName = "websocket";
	WebSocketTransport.roundTrips = 2;
	module.exports = WebSocketTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/lib/buffered-sender.js
var require_buffered_sender = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/lib/buffered-sender.js": ((exports, module) => {
	var inherits$28 = require_inherits_browser(), EventEmitter$13 = require_emitter().EventEmitter;
	var debug$18 = function() {};
	debug$18 = require_browser$1()("sockjs-client:buffered-sender");
	function BufferedSender$1(url, sender) {
		debug$18(url);
		EventEmitter$13.call(this);
		this.sendBuffer = [];
		this.sender = sender;
		this.url = url;
	}
	inherits$28(BufferedSender$1, EventEmitter$13);
	BufferedSender$1.prototype.send = function(message) {
		debug$18("send", message);
		this.sendBuffer.push(message);
		if (!this.sendStop) this.sendSchedule();
	};
	BufferedSender$1.prototype.sendScheduleWait = function() {
		debug$18("sendScheduleWait");
		var self$1 = this;
		var tref;
		this.sendStop = function() {
			debug$18("sendStop");
			self$1.sendStop = null;
			clearTimeout(tref);
		};
		tref = setTimeout(function() {
			debug$18("timeout");
			self$1.sendStop = null;
			self$1.sendSchedule();
		}, 25);
	};
	BufferedSender$1.prototype.sendSchedule = function() {
		debug$18("sendSchedule", this.sendBuffer.length);
		var self$1 = this;
		if (this.sendBuffer.length > 0) {
			var payload = "[" + this.sendBuffer.join(",") + "]";
			this.sendStop = this.sender(this.url, payload, function(err) {
				self$1.sendStop = null;
				if (err) {
					debug$18("error", err);
					self$1.emit("close", err.code || 1006, "Sending error: " + err);
					self$1.close();
				} else self$1.sendScheduleWait();
			});
			this.sendBuffer = [];
		}
	};
	BufferedSender$1.prototype._cleanup = function() {
		debug$18("_cleanup");
		this.removeAllListeners();
	};
	BufferedSender$1.prototype.close = function() {
		debug$18("close");
		this._cleanup();
		if (this.sendStop) {
			this.sendStop();
			this.sendStop = null;
		}
	};
	module.exports = BufferedSender$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/lib/polling.js
var require_polling = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/lib/polling.js": ((exports, module) => {
	var inherits$27 = require_inherits_browser(), EventEmitter$12 = require_emitter().EventEmitter;
	var debug$17 = function() {};
	debug$17 = require_browser$1()("sockjs-client:polling");
	function Polling$1(Receiver, receiveUrl, AjaxObject) {
		debug$17(receiveUrl);
		EventEmitter$12.call(this);
		this.Receiver = Receiver;
		this.receiveUrl = receiveUrl;
		this.AjaxObject = AjaxObject;
		this._scheduleReceiver();
	}
	inherits$27(Polling$1, EventEmitter$12);
	Polling$1.prototype._scheduleReceiver = function() {
		debug$17("_scheduleReceiver");
		var self$1 = this;
		var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);
		poll.on("message", function(msg) {
			debug$17("message", msg);
			self$1.emit("message", msg);
		});
		poll.once("close", function(code, reason) {
			debug$17("close", code, reason, self$1.pollIsClosing);
			self$1.poll = poll = null;
			if (!self$1.pollIsClosing) if (reason === "network") self$1._scheduleReceiver();
			else {
				self$1.emit("close", code || 1006, reason);
				self$1.removeAllListeners();
			}
		});
	};
	Polling$1.prototype.abort = function() {
		debug$17("abort");
		this.removeAllListeners();
		this.pollIsClosing = true;
		if (this.poll) this.poll.abort();
	};
	module.exports = Polling$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/lib/sender-receiver.js
var require_sender_receiver = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/lib/sender-receiver.js": ((exports, module) => {
	var inherits$26 = require_inherits_browser(), urlUtils$10 = require_url(), BufferedSender = require_buffered_sender(), Polling = require_polling();
	var debug$16 = function() {};
	debug$16 = require_browser$1()("sockjs-client:sender-receiver");
	function SenderReceiver$2(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
		var pollUrl = urlUtils$10.addPath(transUrl, urlSuffix);
		debug$16(pollUrl);
		var self$1 = this;
		BufferedSender.call(this, transUrl, senderFunc);
		this.poll = new Polling(Receiver, pollUrl, AjaxObject);
		this.poll.on("message", function(msg) {
			debug$16("poll message", msg);
			self$1.emit("message", msg);
		});
		this.poll.once("close", function(code, reason) {
			debug$16("poll close", code, reason);
			self$1.poll = null;
			self$1.emit("close", code, reason);
			self$1.close();
		});
	}
	inherits$26(SenderReceiver$2, BufferedSender);
	SenderReceiver$2.prototype.close = function() {
		BufferedSender.prototype.close.call(this);
		debug$16("close");
		this.removeAllListeners();
		if (this.poll) {
			this.poll.abort();
			this.poll = null;
		}
	};
	module.exports = SenderReceiver$2;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/lib/ajax-based.js
var require_ajax_based = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/lib/ajax-based.js": ((exports, module) => {
	var inherits$25 = require_inherits_browser(), urlUtils$9 = require_url(), SenderReceiver$1 = require_sender_receiver();
	var debug$15 = function() {};
	debug$15 = require_browser$1()("sockjs-client:ajax-based");
	function createAjaxSender(AjaxObject) {
		return function(url, payload, callback) {
			debug$15("create ajax sender", url, payload);
			var opt = {};
			if (typeof payload === "string") opt.headers = { "Content-type": "text/plain" };
			var xo = new AjaxObject("POST", urlUtils$9.addPath(url, "/xhr_send"), payload, opt);
			xo.once("finish", function(status) {
				debug$15("finish", status);
				xo = null;
				if (status !== 200 && status !== 204) return callback(/* @__PURE__ */ new Error("http status " + status));
				callback();
			});
			return function() {
				debug$15("abort");
				xo.close();
				xo = null;
				var err = /* @__PURE__ */ new Error("Aborted");
				err.code = 1e3;
				callback(err);
			};
		};
	}
	function AjaxBasedTransport$6(transUrl, urlSuffix, Receiver, AjaxObject) {
		SenderReceiver$1.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
	}
	inherits$25(AjaxBasedTransport$6, SenderReceiver$1);
	module.exports = AjaxBasedTransport$6;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/receiver/xhr.js
var require_xhr = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/receiver/xhr.js": ((exports, module) => {
	var inherits$24 = require_inherits_browser(), EventEmitter$11 = require_emitter().EventEmitter;
	var debug$14 = function() {};
	debug$14 = require_browser$1()("sockjs-client:receiver:xhr");
	function XhrReceiver$4(url, AjaxObject) {
		debug$14(url);
		EventEmitter$11.call(this);
		var self$1 = this;
		this.bufferPosition = 0;
		this.xo = new AjaxObject("POST", url, null);
		this.xo.on("chunk", this._chunkHandler.bind(this));
		this.xo.once("finish", function(status, text) {
			debug$14("finish", status, text);
			self$1._chunkHandler(status, text);
			self$1.xo = null;
			var reason = status === 200 ? "network" : "permanent";
			debug$14("close", reason);
			self$1.emit("close", null, reason);
			self$1._cleanup();
		});
	}
	inherits$24(XhrReceiver$4, EventEmitter$11);
	XhrReceiver$4.prototype._chunkHandler = function(status, text) {
		debug$14("_chunkHandler", status);
		if (status !== 200 || !text) return;
		for (var idx = -1;; this.bufferPosition += idx + 1) {
			var buf = text.slice(this.bufferPosition);
			idx = buf.indexOf("\n");
			if (idx === -1) break;
			var msg = buf.slice(0, idx);
			if (msg) {
				debug$14("message", msg);
				this.emit("message", msg);
			}
		}
	};
	XhrReceiver$4.prototype._cleanup = function() {
		debug$14("_cleanup");
		this.removeAllListeners();
	};
	XhrReceiver$4.prototype.abort = function() {
		debug$14("abort");
		if (this.xo) {
			this.xo.close();
			debug$14("close");
			this.emit("close", null, "user");
			this.xo = null;
		}
		this._cleanup();
	};
	module.exports = XhrReceiver$4;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/browser/abstract-xhr.js
var require_abstract_xhr = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/browser/abstract-xhr.js": ((exports, module) => {
	var EventEmitter$10 = require_emitter().EventEmitter, inherits$23 = require_inherits_browser(), utils$2 = require_event$1(), urlUtils$8 = require_url(), XHR = global.XMLHttpRequest;
	var debug$13 = function() {};
	debug$13 = require_browser$1()("sockjs-client:browser:xhr");
	function AbstractXHRObject(method, url, payload, opts) {
		debug$13(method, url);
		var self$1 = this;
		EventEmitter$10.call(this);
		setTimeout(function() {
			self$1._start(method, url, payload, opts);
		}, 0);
	}
	inherits$23(AbstractXHRObject, EventEmitter$10);
	AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
		var self$1 = this;
		try {
			this.xhr = new XHR();
		} catch (x) {}
		if (!this.xhr) {
			debug$13("no xhr");
			this.emit("finish", 0, "no xhr support");
			this._cleanup();
			return;
		}
		url = urlUtils$8.addQuery(url, "t=" + +/* @__PURE__ */ new Date());
		this.unloadRef = utils$2.unloadAdd(function() {
			debug$13("unload cleanup");
			self$1._cleanup(true);
		});
		try {
			this.xhr.open(method, url, true);
			if (this.timeout && "timeout" in this.xhr) {
				this.xhr.timeout = this.timeout;
				this.xhr.ontimeout = function() {
					debug$13("xhr timeout");
					self$1.emit("finish", 0, "");
					self$1._cleanup(false);
				};
			}
		} catch (e) {
			debug$13("exception", e);
			this.emit("finish", 0, "");
			this._cleanup(false);
			return;
		}
		if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
			debug$13("withCredentials");
			this.xhr.withCredentials = true;
		}
		if (opts && opts.headers) for (var key in opts.headers) this.xhr.setRequestHeader(key, opts.headers[key]);
		this.xhr.onreadystatechange = function() {
			if (self$1.xhr) {
				var x = self$1.xhr;
				var text, status;
				debug$13("readyState", x.readyState);
				switch (x.readyState) {
					case 3:
						try {
							status = x.status;
							text = x.responseText;
						} catch (e) {}
						debug$13("status", status);
						if (status === 1223) status = 204;
						if (status === 200 && text && text.length > 0) {
							debug$13("chunk");
							self$1.emit("chunk", status, text);
						}
						break;
					case 4:
						status = x.status;
						debug$13("status", status);
						if (status === 1223) status = 204;
						if (status === 12005 || status === 12029) status = 0;
						debug$13("finish", status, x.responseText);
						self$1.emit("finish", status, x.responseText);
						self$1._cleanup(false);
						break;
				}
			}
		};
		try {
			self$1.xhr.send(payload);
		} catch (e) {
			self$1.emit("finish", 0, "");
			self$1._cleanup(false);
		}
	};
	AbstractXHRObject.prototype._cleanup = function(abort) {
		debug$13("cleanup");
		if (!this.xhr) return;
		this.removeAllListeners();
		utils$2.unloadDel(this.unloadRef);
		this.xhr.onreadystatechange = function() {};
		if (this.xhr.ontimeout) this.xhr.ontimeout = null;
		if (abort) try {
			this.xhr.abort();
		} catch (x) {}
		this.unloadRef = this.xhr = null;
	};
	AbstractXHRObject.prototype.close = function() {
		debug$13("close");
		this._cleanup(true);
	};
	AbstractXHRObject.enabled = !!XHR;
	var axo$1 = ["Active"].concat("Object").join("X");
	if (!AbstractXHRObject.enabled && axo$1 in global) {
		debug$13("overriding xmlhttprequest");
		XHR = function() {
			try {
				return new global[axo$1]("Microsoft.XMLHTTP");
			} catch (e) {
				return null;
			}
		};
		AbstractXHRObject.enabled = !!new XHR();
	}
	var cors = false;
	try {
		cors = "withCredentials" in new XHR();
	} catch (ignored) {}
	AbstractXHRObject.supportsCORS = cors;
	module.exports = AbstractXHRObject;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/sender/xhr-cors.js
var require_xhr_cors = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/sender/xhr-cors.js": ((exports, module) => {
	var inherits$22 = require_inherits_browser(), XhrDriver$1 = require_abstract_xhr();
	function XHRCorsObject$3(method, url, payload, opts) {
		XhrDriver$1.call(this, method, url, payload, opts);
	}
	inherits$22(XHRCorsObject$3, XhrDriver$1);
	XHRCorsObject$3.enabled = XhrDriver$1.enabled && XhrDriver$1.supportsCORS;
	module.exports = XHRCorsObject$3;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/sender/xhr-local.js
var require_xhr_local = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/sender/xhr-local.js": ((exports, module) => {
	var inherits$21 = require_inherits_browser(), XhrDriver = require_abstract_xhr();
	function XHRLocalObject$4(method, url, payload) {
		XhrDriver.call(this, method, url, payload, { noCredentials: true });
	}
	inherits$21(XHRLocalObject$4, XhrDriver);
	XHRLocalObject$4.enabled = XhrDriver.enabled;
	module.exports = XHRLocalObject$4;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/browser.js
var require_browser = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/browser.js": ((exports, module) => {
	module.exports = {
		isOpera: function() {
			return global.navigator && /opera/i.test(global.navigator.userAgent);
		},
		isKonqueror: function() {
			return global.navigator && /konqueror/i.test(global.navigator.userAgent);
		},
		hasDomain: function() {
			if (!global.document) return true;
			try {
				return !!global.document.domain;
			} catch (e) {
				return false;
			}
		}
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/xhr-streaming.js
var require_xhr_streaming = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/xhr-streaming.js": ((exports, module) => {
	var inherits$20 = require_inherits_browser(), AjaxBasedTransport$5 = require_ajax_based(), XhrReceiver$3 = require_xhr(), XHRCorsObject$2 = require_xhr_cors(), XHRLocalObject$3 = require_xhr_local(), browser$4 = require_browser();
	function XhrStreamingTransport(transUrl) {
		if (!XHRLocalObject$3.enabled && !XHRCorsObject$2.enabled) throw new Error("Transport created when disabled");
		AjaxBasedTransport$5.call(this, transUrl, "/xhr_streaming", XhrReceiver$3, XHRCorsObject$2);
	}
	inherits$20(XhrStreamingTransport, AjaxBasedTransport$5);
	XhrStreamingTransport.enabled = function(info) {
		if (info.nullOrigin) return false;
		if (browser$4.isOpera()) return false;
		return XHRCorsObject$2.enabled;
	};
	XhrStreamingTransport.transportName = "xhr-streaming";
	XhrStreamingTransport.roundTrips = 2;
	XhrStreamingTransport.needBody = !!global.document;
	module.exports = XhrStreamingTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/sender/xdr.js
var require_xdr = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/sender/xdr.js": ((exports, module) => {
	var EventEmitter$9 = require_emitter().EventEmitter, inherits$19 = require_inherits_browser(), eventUtils$4 = require_event$1(), browser$3 = require_browser(), urlUtils$7 = require_url();
	var debug$12 = function() {};
	debug$12 = require_browser$1()("sockjs-client:sender:xdr");
	function XDRObject$2(method, url, payload) {
		debug$12(method, url);
		var self$1 = this;
		EventEmitter$9.call(this);
		setTimeout(function() {
			self$1._start(method, url, payload);
		}, 0);
	}
	inherits$19(XDRObject$2, EventEmitter$9);
	XDRObject$2.prototype._start = function(method, url, payload) {
		debug$12("_start");
		var self$1 = this;
		var xdr = new global.XDomainRequest();
		url = urlUtils$7.addQuery(url, "t=" + +/* @__PURE__ */ new Date());
		xdr.onerror = function() {
			debug$12("onerror");
			self$1._error();
		};
		xdr.ontimeout = function() {
			debug$12("ontimeout");
			self$1._error();
		};
		xdr.onprogress = function() {
			debug$12("progress", xdr.responseText);
			self$1.emit("chunk", 200, xdr.responseText);
		};
		xdr.onload = function() {
			debug$12("load");
			self$1.emit("finish", 200, xdr.responseText);
			self$1._cleanup(false);
		};
		this.xdr = xdr;
		this.unloadRef = eventUtils$4.unloadAdd(function() {
			self$1._cleanup(true);
		});
		try {
			this.xdr.open(method, url);
			if (this.timeout) this.xdr.timeout = this.timeout;
			this.xdr.send(payload);
		} catch (x) {
			this._error();
		}
	};
	XDRObject$2.prototype._error = function() {
		this.emit("finish", 0, "");
		this._cleanup(false);
	};
	XDRObject$2.prototype._cleanup = function(abort) {
		debug$12("cleanup", abort);
		if (!this.xdr) return;
		this.removeAllListeners();
		eventUtils$4.unloadDel(this.unloadRef);
		this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
		if (abort) try {
			this.xdr.abort();
		} catch (x) {}
		this.unloadRef = this.xdr = null;
	};
	XDRObject$2.prototype.close = function() {
		debug$12("close");
		this._cleanup(true);
	};
	XDRObject$2.enabled = !!(global.XDomainRequest && browser$3.hasDomain());
	module.exports = XDRObject$2;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/xdr-streaming.js
var require_xdr_streaming = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/xdr-streaming.js": ((exports, module) => {
	var inherits$18 = require_inherits_browser(), AjaxBasedTransport$4 = require_ajax_based(), XhrReceiver$2 = require_xhr(), XDRObject$1 = require_xdr();
	function XdrStreamingTransport$1(transUrl) {
		if (!XDRObject$1.enabled) throw new Error("Transport created when disabled");
		AjaxBasedTransport$4.call(this, transUrl, "/xhr_streaming", XhrReceiver$2, XDRObject$1);
	}
	inherits$18(XdrStreamingTransport$1, AjaxBasedTransport$4);
	XdrStreamingTransport$1.enabled = function(info) {
		if (info.cookie_needed || info.nullOrigin) return false;
		return XDRObject$1.enabled && info.sameScheme;
	};
	XdrStreamingTransport$1.transportName = "xdr-streaming";
	XdrStreamingTransport$1.roundTrips = 2;
	module.exports = XdrStreamingTransport$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/browser/eventsource.js
var require_eventsource$2 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/browser/eventsource.js": ((exports, module) => {
	module.exports = global.EventSource;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/receiver/eventsource.js
var require_eventsource$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/receiver/eventsource.js": ((exports, module) => {
	var inherits$17 = require_inherits_browser(), EventEmitter$8 = require_emitter().EventEmitter, EventSourceDriver$1 = require_eventsource$2();
	var debug$11 = function() {};
	debug$11 = require_browser$1()("sockjs-client:receiver:eventsource");
	function EventSourceReceiver$1(url) {
		debug$11(url);
		EventEmitter$8.call(this);
		var self$1 = this;
		var es = this.es = new EventSourceDriver$1(url);
		es.onmessage = function(e) {
			debug$11("message", e.data);
			self$1.emit("message", decodeURI(e.data));
		};
		es.onerror = function(e) {
			debug$11("error", es.readyState, e);
			var reason = es.readyState !== 2 ? "network" : "permanent";
			self$1._cleanup();
			self$1._close(reason);
		};
	}
	inherits$17(EventSourceReceiver$1, EventEmitter$8);
	EventSourceReceiver$1.prototype.abort = function() {
		debug$11("abort");
		this._cleanup();
		this._close("user");
	};
	EventSourceReceiver$1.prototype._cleanup = function() {
		debug$11("cleanup");
		var es = this.es;
		if (es) {
			es.onmessage = es.onerror = null;
			es.close();
			this.es = null;
		}
	};
	EventSourceReceiver$1.prototype._close = function(reason) {
		debug$11("close", reason);
		var self$1 = this;
		setTimeout(function() {
			self$1.emit("close", null, reason);
			self$1.removeAllListeners();
		}, 200);
	};
	module.exports = EventSourceReceiver$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/eventsource.js
var require_eventsource = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/eventsource.js": ((exports, module) => {
	var inherits$16 = require_inherits_browser(), AjaxBasedTransport$3 = require_ajax_based(), EventSourceReceiver = require_eventsource$1(), XHRCorsObject$1 = require_xhr_cors(), EventSourceDriver = require_eventsource$2();
	function EventSourceTransport(transUrl) {
		if (!EventSourceTransport.enabled()) throw new Error("Transport created when disabled");
		AjaxBasedTransport$3.call(this, transUrl, "/eventsource", EventSourceReceiver, XHRCorsObject$1);
	}
	inherits$16(EventSourceTransport, AjaxBasedTransport$3);
	EventSourceTransport.enabled = function() {
		return !!EventSourceDriver;
	};
	EventSourceTransport.transportName = "eventsource";
	EventSourceTransport.roundTrips = 2;
	module.exports = EventSourceTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/version.js
var require_version = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/version.js": ((exports, module) => {
	module.exports = "1.6.1";
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/iframe.js
var require_iframe$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/iframe.js": ((exports, module) => {
	var eventUtils$3 = require_event$1(), browser$2 = require_browser();
	var debug$10 = function() {};
	debug$10 = require_browser$1()("sockjs-client:utils:iframe");
	module.exports = {
		WPrefix: "_jp",
		currentWindowId: null,
		polluteGlobalNamespace: function() {
			if (!(module.exports.WPrefix in global)) global[module.exports.WPrefix] = {};
		},
		postMessage: function(type, data) {
			if (global.parent !== global) global.parent.postMessage(JSON.stringify({
				windowId: module.exports.currentWindowId,
				type,
				data: data || ""
			}), "*");
			else debug$10("Cannot postMessage, no parent window.", type, data);
		},
		createIframe: function(iframeUrl, errorCallback) {
			var iframe = global.document.createElement("iframe");
			var tref, unloadRef;
			var unattach = function() {
				debug$10("unattach");
				clearTimeout(tref);
				try {
					iframe.onload = null;
				} catch (x) {}
				iframe.onerror = null;
			};
			var cleanup = function() {
				debug$10("cleanup");
				if (iframe) {
					unattach();
					setTimeout(function() {
						if (iframe) iframe.parentNode.removeChild(iframe);
						iframe = null;
					}, 0);
					eventUtils$3.unloadDel(unloadRef);
				}
			};
			var onerror = function(err) {
				debug$10("onerror", err);
				if (iframe) {
					cleanup();
					errorCallback(err);
				}
			};
			var post = function(msg, origin) {
				debug$10("post", msg, origin);
				setTimeout(function() {
					try {
						if (iframe && iframe.contentWindow) iframe.contentWindow.postMessage(msg, origin);
					} catch (x) {}
				}, 0);
			};
			iframe.src = iframeUrl;
			iframe.style.display = "none";
			iframe.style.position = "absolute";
			iframe.onerror = function() {
				onerror("onerror");
			};
			iframe.onload = function() {
				debug$10("onload");
				clearTimeout(tref);
				tref = setTimeout(function() {
					onerror("onload timeout");
				}, 2e3);
			};
			global.document.body.appendChild(iframe);
			tref = setTimeout(function() {
				onerror("timeout");
			}, 15e3);
			unloadRef = eventUtils$3.unloadAdd(cleanup);
			return {
				post,
				cleanup,
				loaded: unattach
			};
		},
		createHtmlfile: function(iframeUrl, errorCallback) {
			var axo$2 = ["Active"].concat("Object").join("X");
			var doc = new global[axo$2]("htmlfile");
			var tref, unloadRef;
			var iframe;
			var unattach = function() {
				clearTimeout(tref);
				iframe.onerror = null;
			};
			var cleanup = function() {
				if (doc) {
					unattach();
					eventUtils$3.unloadDel(unloadRef);
					iframe.parentNode.removeChild(iframe);
					iframe = doc = null;
					CollectGarbage();
				}
			};
			var onerror = function(r) {
				debug$10("onerror", r);
				if (doc) {
					cleanup();
					errorCallback(r);
				}
			};
			var post = function(msg, origin) {
				try {
					setTimeout(function() {
						if (iframe && iframe.contentWindow) iframe.contentWindow.postMessage(msg, origin);
					}, 0);
				} catch (x) {}
			};
			doc.open();
			doc.write("<html><script>document.domain=\"" + global.document.domain + "\";<\/script></html>");
			doc.close();
			doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
			var c = doc.createElement("div");
			doc.body.appendChild(c);
			iframe = doc.createElement("iframe");
			c.appendChild(iframe);
			iframe.src = iframeUrl;
			iframe.onerror = function() {
				onerror("onerror");
			};
			tref = setTimeout(function() {
				onerror("timeout");
			}, 15e3);
			unloadRef = eventUtils$3.unloadAdd(cleanup);
			return {
				post,
				cleanup,
				loaded: unattach
			};
		}
	};
	module.exports.iframeEnabled = false;
	if (global.document) module.exports.iframeEnabled = (typeof global.postMessage === "function" || typeof global.postMessage === "object") && !browser$2.isKonqueror();
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/iframe.js
var require_iframe = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/iframe.js": ((exports, module) => {
	var inherits$15 = require_inherits_browser(), EventEmitter$7 = require_emitter().EventEmitter, version = require_version(), urlUtils$6 = require_url(), iframeUtils$3 = require_iframe$1(), eventUtils$2 = require_event$1(), random$4 = require_random();
	var debug$9 = function() {};
	debug$9 = require_browser$1()("sockjs-client:transport:iframe");
	function IframeTransport$2(transport$1, transUrl, baseUrl) {
		if (!IframeTransport$2.enabled()) throw new Error("Transport created when disabled");
		EventEmitter$7.call(this);
		var self$1 = this;
		this.origin = urlUtils$6.getOrigin(baseUrl);
		this.baseUrl = baseUrl;
		this.transUrl = transUrl;
		this.transport = transport$1;
		this.windowId = random$4.string(8);
		var iframeUrl = urlUtils$6.addPath(baseUrl, "/iframe.html") + "#" + this.windowId;
		debug$9(transport$1, transUrl, iframeUrl);
		this.iframeObj = iframeUtils$3.createIframe(iframeUrl, function(r) {
			debug$9("err callback");
			self$1.emit("close", 1006, "Unable to load an iframe (" + r + ")");
			self$1.close();
		});
		this.onmessageCallback = this._message.bind(this);
		eventUtils$2.attachEvent("message", this.onmessageCallback);
	}
	inherits$15(IframeTransport$2, EventEmitter$7);
	IframeTransport$2.prototype.close = function() {
		debug$9("close");
		this.removeAllListeners();
		if (this.iframeObj) {
			eventUtils$2.detachEvent("message", this.onmessageCallback);
			try {
				this.postMessage("c");
			} catch (x) {}
			this.iframeObj.cleanup();
			this.iframeObj = null;
			this.onmessageCallback = this.iframeObj = null;
		}
	};
	IframeTransport$2.prototype._message = function(e) {
		debug$9("message", e.data);
		if (!urlUtils$6.isOriginEqual(e.origin, this.origin)) {
			debug$9("not same origin", e.origin, this.origin);
			return;
		}
		var iframeMessage;
		try {
			iframeMessage = JSON.parse(e.data);
		} catch (ignored) {
			debug$9("bad json", e.data);
			return;
		}
		if (iframeMessage.windowId !== this.windowId) {
			debug$9("mismatched window id", iframeMessage.windowId, this.windowId);
			return;
		}
		switch (iframeMessage.type) {
			case "s":
				this.iframeObj.loaded();
				this.postMessage("s", JSON.stringify([
					version,
					this.transport,
					this.transUrl,
					this.baseUrl
				]));
				break;
			case "t":
				this.emit("message", iframeMessage.data);
				break;
			case "c":
				var cdata;
				try {
					cdata = JSON.parse(iframeMessage.data);
				} catch (ignored) {
					debug$9("bad json", iframeMessage.data);
					return;
				}
				this.emit("close", cdata[0], cdata[1]);
				this.close();
				break;
		}
	};
	IframeTransport$2.prototype.postMessage = function(type, data) {
		debug$9("postMessage", type, data);
		this.iframeObj.post(JSON.stringify({
			windowId: this.windowId,
			type,
			data: data || ""
		}), this.origin);
	};
	IframeTransport$2.prototype.send = function(message) {
		debug$9("send", message);
		this.postMessage("m", message);
	};
	IframeTransport$2.enabled = function() {
		return iframeUtils$3.iframeEnabled;
	};
	IframeTransport$2.transportName = "iframe";
	IframeTransport$2.roundTrips = 2;
	module.exports = IframeTransport$2;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/object.js
var require_object = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/object.js": ((exports, module) => {
	module.exports = {
		isObject: function(obj) {
			var type = typeof obj;
			return type === "function" || type === "object" && !!obj;
		},
		extend: function(obj) {
			if (!this.isObject(obj)) return obj;
			var source, prop;
			for (var i = 1, length = arguments.length; i < length; i++) {
				source = arguments[i];
				for (prop in source) if (Object.prototype.hasOwnProperty.call(source, prop)) obj[prop] = source[prop];
			}
			return obj;
		}
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/lib/iframe-wrap.js
var require_iframe_wrap = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/lib/iframe-wrap.js": ((exports, module) => {
	var inherits$14 = require_inherits_browser(), IframeTransport$1 = require_iframe(), objectUtils$2 = require_object();
	module.exports = function(transport$1) {
		function IframeWrapTransport(transUrl, baseUrl) {
			IframeTransport$1.call(this, transport$1.transportName, transUrl, baseUrl);
		}
		inherits$14(IframeWrapTransport, IframeTransport$1);
		IframeWrapTransport.enabled = function(url, info) {
			if (!global.document) return false;
			var iframeInfo = objectUtils$2.extend({}, info);
			iframeInfo.sameOrigin = true;
			return transport$1.enabled(iframeInfo) && IframeTransport$1.enabled();
		};
		IframeWrapTransport.transportName = "iframe-" + transport$1.transportName;
		IframeWrapTransport.needBody = true;
		IframeWrapTransport.roundTrips = IframeTransport$1.roundTrips + transport$1.roundTrips - 1;
		IframeWrapTransport.facadeTransport = transport$1;
		return IframeWrapTransport;
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/receiver/htmlfile.js
var require_htmlfile$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/receiver/htmlfile.js": ((exports, module) => {
	var inherits$13 = require_inherits_browser(), iframeUtils$2 = require_iframe$1(), urlUtils$5 = require_url(), EventEmitter$6 = require_emitter().EventEmitter, random$3 = require_random();
	var debug$8 = function() {};
	debug$8 = require_browser$1()("sockjs-client:receiver:htmlfile");
	function HtmlfileReceiver$1(url) {
		debug$8(url);
		EventEmitter$6.call(this);
		var self$1 = this;
		iframeUtils$2.polluteGlobalNamespace();
		this.id = "a" + random$3.string(6);
		url = urlUtils$5.addQuery(url, "c=" + decodeURIComponent(iframeUtils$2.WPrefix + "." + this.id));
		debug$8("using htmlfile", HtmlfileReceiver$1.htmlfileEnabled);
		var constructFunc = HtmlfileReceiver$1.htmlfileEnabled ? iframeUtils$2.createHtmlfile : iframeUtils$2.createIframe;
		global[iframeUtils$2.WPrefix][this.id] = {
			start: function() {
				debug$8("start");
				self$1.iframeObj.loaded();
			},
			message: function(data) {
				debug$8("message", data);
				self$1.emit("message", data);
			},
			stop: function() {
				debug$8("stop");
				self$1._cleanup();
				self$1._close("network");
			}
		};
		this.iframeObj = constructFunc(url, function() {
			debug$8("callback");
			self$1._cleanup();
			self$1._close("permanent");
		});
	}
	inherits$13(HtmlfileReceiver$1, EventEmitter$6);
	HtmlfileReceiver$1.prototype.abort = function() {
		debug$8("abort");
		this._cleanup();
		this._close("user");
	};
	HtmlfileReceiver$1.prototype._cleanup = function() {
		debug$8("_cleanup");
		if (this.iframeObj) {
			this.iframeObj.cleanup();
			this.iframeObj = null;
		}
		delete global[iframeUtils$2.WPrefix][this.id];
	};
	HtmlfileReceiver$1.prototype._close = function(reason) {
		debug$8("_close", reason);
		this.emit("close", null, reason);
		this.removeAllListeners();
	};
	HtmlfileReceiver$1.htmlfileEnabled = false;
	var axo = ["Active"].concat("Object").join("X");
	if (axo in global) try {
		HtmlfileReceiver$1.htmlfileEnabled = !!new global[axo]("htmlfile");
	} catch (x) {}
	HtmlfileReceiver$1.enabled = HtmlfileReceiver$1.htmlfileEnabled || iframeUtils$2.iframeEnabled;
	module.exports = HtmlfileReceiver$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/htmlfile.js
var require_htmlfile = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/htmlfile.js": ((exports, module) => {
	var inherits$12 = require_inherits_browser(), HtmlfileReceiver = require_htmlfile$1(), XHRLocalObject$2 = require_xhr_local(), AjaxBasedTransport$2 = require_ajax_based();
	function HtmlFileTransport(transUrl) {
		if (!HtmlfileReceiver.enabled) throw new Error("Transport created when disabled");
		AjaxBasedTransport$2.call(this, transUrl, "/htmlfile", HtmlfileReceiver, XHRLocalObject$2);
	}
	inherits$12(HtmlFileTransport, AjaxBasedTransport$2);
	HtmlFileTransport.enabled = function(info) {
		return HtmlfileReceiver.enabled && info.sameOrigin;
	};
	HtmlFileTransport.transportName = "htmlfile";
	HtmlFileTransport.roundTrips = 2;
	module.exports = HtmlFileTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/xhr-polling.js
var require_xhr_polling = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/xhr-polling.js": ((exports, module) => {
	var inherits$11 = require_inherits_browser(), AjaxBasedTransport$1 = require_ajax_based(), XhrReceiver$1 = require_xhr(), XHRCorsObject = require_xhr_cors(), XHRLocalObject$1 = require_xhr_local();
	function XhrPollingTransport(transUrl) {
		if (!XHRLocalObject$1.enabled && !XHRCorsObject.enabled) throw new Error("Transport created when disabled");
		AjaxBasedTransport$1.call(this, transUrl, "/xhr", XhrReceiver$1, XHRCorsObject);
	}
	inherits$11(XhrPollingTransport, AjaxBasedTransport$1);
	XhrPollingTransport.enabled = function(info) {
		if (info.nullOrigin) return false;
		if (XHRLocalObject$1.enabled && info.sameOrigin) return true;
		return XHRCorsObject.enabled;
	};
	XhrPollingTransport.transportName = "xhr-polling";
	XhrPollingTransport.roundTrips = 2;
	module.exports = XhrPollingTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/xdr-polling.js
var require_xdr_polling = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/xdr-polling.js": ((exports, module) => {
	var inherits$10 = require_inherits_browser(), AjaxBasedTransport = require_ajax_based(), XdrStreamingTransport = require_xdr_streaming(), XhrReceiver = require_xhr(), XDRObject = require_xdr();
	function XdrPollingTransport(transUrl) {
		if (!XDRObject.enabled) throw new Error("Transport created when disabled");
		AjaxBasedTransport.call(this, transUrl, "/xhr", XhrReceiver, XDRObject);
	}
	inherits$10(XdrPollingTransport, AjaxBasedTransport);
	XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
	XdrPollingTransport.transportName = "xdr-polling";
	XdrPollingTransport.roundTrips = 2;
	module.exports = XdrPollingTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/receiver/jsonp.js
var require_jsonp$1 = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/receiver/jsonp.js": ((exports, module) => {
	var utils$1 = require_iframe$1(), random$2 = require_random(), browser$1 = require_browser(), urlUtils$4 = require_url(), inherits$9 = require_inherits_browser(), EventEmitter$5 = require_emitter().EventEmitter;
	var debug$7 = function() {};
	debug$7 = require_browser$1()("sockjs-client:receiver:jsonp");
	function JsonpReceiver$1(url) {
		debug$7(url);
		var self$1 = this;
		EventEmitter$5.call(this);
		utils$1.polluteGlobalNamespace();
		this.id = "a" + random$2.string(6);
		var urlWithId = urlUtils$4.addQuery(url, "c=" + encodeURIComponent(utils$1.WPrefix + "." + this.id));
		global[utils$1.WPrefix][this.id] = this._callback.bind(this);
		this._createScript(urlWithId);
		this.timeoutId = setTimeout(function() {
			debug$7("timeout");
			self$1._abort(/* @__PURE__ */ new Error("JSONP script loaded abnormally (timeout)"));
		}, JsonpReceiver$1.timeout);
	}
	inherits$9(JsonpReceiver$1, EventEmitter$5);
	JsonpReceiver$1.prototype.abort = function() {
		debug$7("abort");
		if (global[utils$1.WPrefix][this.id]) {
			var err = /* @__PURE__ */ new Error("JSONP user aborted read");
			err.code = 1e3;
			this._abort(err);
		}
	};
	JsonpReceiver$1.timeout = 35e3;
	JsonpReceiver$1.scriptErrorTimeout = 1e3;
	JsonpReceiver$1.prototype._callback = function(data) {
		debug$7("_callback", data);
		this._cleanup();
		if (this.aborting) return;
		if (data) {
			debug$7("message", data);
			this.emit("message", data);
		}
		this.emit("close", null, "network");
		this.removeAllListeners();
	};
	JsonpReceiver$1.prototype._abort = function(err) {
		debug$7("_abort", err);
		this._cleanup();
		this.aborting = true;
		this.emit("close", err.code, err.message);
		this.removeAllListeners();
	};
	JsonpReceiver$1.prototype._cleanup = function() {
		debug$7("_cleanup");
		clearTimeout(this.timeoutId);
		if (this.script2) {
			this.script2.parentNode.removeChild(this.script2);
			this.script2 = null;
		}
		if (this.script) {
			var script = this.script;
			script.parentNode.removeChild(script);
			script.onreadystatechange = script.onerror = script.onload = script.onclick = null;
			this.script = null;
		}
		delete global[utils$1.WPrefix][this.id];
	};
	JsonpReceiver$1.prototype._scriptError = function() {
		debug$7("_scriptError");
		var self$1 = this;
		if (this.errorTimer) return;
		this.errorTimer = setTimeout(function() {
			if (!self$1.loadedOkay) self$1._abort(/* @__PURE__ */ new Error("JSONP script loaded abnormally (onerror)"));
		}, JsonpReceiver$1.scriptErrorTimeout);
	};
	JsonpReceiver$1.prototype._createScript = function(url) {
		debug$7("_createScript", url);
		var self$1 = this;
		var script = this.script = global.document.createElement("script");
		var script2;
		script.id = "a" + random$2.string(8);
		script.src = url;
		script.type = "text/javascript";
		script.charset = "UTF-8";
		script.onerror = this._scriptError.bind(this);
		script.onload = function() {
			debug$7("onload");
			self$1._abort(/* @__PURE__ */ new Error("JSONP script loaded abnormally (onload)"));
		};
		script.onreadystatechange = function() {
			debug$7("onreadystatechange", script.readyState);
			if (/loaded|closed/.test(script.readyState)) {
				if (script && script.htmlFor && script.onclick) {
					self$1.loadedOkay = true;
					try {
						script.onclick();
					} catch (x) {}
				}
				if (script) self$1._abort(/* @__PURE__ */ new Error("JSONP script loaded abnormally (onreadystatechange)"));
			}
		};
		if (typeof script.async === "undefined" && global.document.attachEvent) if (!browser$1.isOpera()) {
			try {
				script.htmlFor = script.id;
				script.event = "onclick";
			} catch (x) {}
			script.async = true;
		} else {
			script2 = this.script2 = global.document.createElement("script");
			script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
			script.async = script2.async = false;
		}
		if (typeof script.async !== "undefined") script.async = true;
		var head = global.document.getElementsByTagName("head")[0];
		head.insertBefore(script, head.firstChild);
		if (script2) head.insertBefore(script2, head.firstChild);
	};
	module.exports = JsonpReceiver$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/sender/jsonp.js
var require_jsonp = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/sender/jsonp.js": ((exports, module) => {
	var random$1 = require_random(), urlUtils$3 = require_url();
	var debug$6 = function() {};
	debug$6 = require_browser$1()("sockjs-client:sender:jsonp");
	var form, area;
	function createIframe(id) {
		debug$6("createIframe", id);
		try {
			return global.document.createElement("<iframe name=\"" + id + "\">");
		} catch (x) {
			var iframe = global.document.createElement("iframe");
			iframe.name = id;
			return iframe;
		}
	}
	function createForm() {
		debug$6("createForm");
		form = global.document.createElement("form");
		form.style.display = "none";
		form.style.position = "absolute";
		form.method = "POST";
		form.enctype = "application/x-www-form-urlencoded";
		form.acceptCharset = "UTF-8";
		area = global.document.createElement("textarea");
		area.name = "d";
		form.appendChild(area);
		global.document.body.appendChild(form);
	}
	module.exports = function(url, payload, callback) {
		debug$6(url, payload);
		if (!form) createForm();
		var id = "a" + random$1.string(8);
		form.target = id;
		form.action = urlUtils$3.addQuery(urlUtils$3.addPath(url, "/jsonp_send"), "i=" + id);
		var iframe = createIframe(id);
		iframe.id = id;
		iframe.style.display = "none";
		form.appendChild(iframe);
		try {
			area.value = payload;
		} catch (e) {}
		form.submit();
		var completed = function(err) {
			debug$6("completed", id, err);
			if (!iframe.onerror) return;
			iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
			setTimeout(function() {
				debug$6("cleaning up", id);
				iframe.parentNode.removeChild(iframe);
				iframe = null;
			}, 500);
			area.value = "";
			callback(err);
		};
		iframe.onerror = function() {
			debug$6("onerror", id);
			completed();
		};
		iframe.onload = function() {
			debug$6("onload", id);
			completed();
		};
		iframe.onreadystatechange = function(e) {
			debug$6("onreadystatechange", id, iframe.readyState, e);
			if (iframe.readyState === "complete") completed();
		};
		return function() {
			debug$6("aborted", id);
			completed(/* @__PURE__ */ new Error("Aborted"));
		};
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/jsonp-polling.js
var require_jsonp_polling = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/jsonp-polling.js": ((exports, module) => {
	var inherits$8 = require_inherits_browser(), SenderReceiver = require_sender_receiver(), JsonpReceiver = require_jsonp$1(), jsonpSender = require_jsonp();
	function JsonPTransport(transUrl) {
		if (!JsonPTransport.enabled()) throw new Error("Transport created when disabled");
		SenderReceiver.call(this, transUrl, "/jsonp", jsonpSender, JsonpReceiver);
	}
	inherits$8(JsonPTransport, SenderReceiver);
	JsonPTransport.enabled = function() {
		return !!global.document;
	};
	JsonPTransport.transportName = "jsonp-polling";
	JsonPTransport.roundTrips = 1;
	JsonPTransport.needBody = true;
	module.exports = JsonPTransport;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport-list.js
var require_transport_list = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport-list.js": ((exports, module) => {
	module.exports = [
		require_websocket(),
		require_xhr_streaming(),
		require_xdr_streaming(),
		require_eventsource(),
		require_iframe_wrap()(require_eventsource()),
		require_htmlfile(),
		require_iframe_wrap()(require_htmlfile()),
		require_xhr_polling(),
		require_xdr_polling(),
		require_iframe_wrap()(require_xhr_polling()),
		require_jsonp_polling()
	];
}) });

//#endregion
//#region node_modules/sockjs-client/lib/shims.js
var require_shims = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/shims.js": (() => {
	var ArrayPrototype = Array.prototype;
	var ObjectPrototype = Object.prototype;
	var FunctionPrototype = Function.prototype;
	var StringPrototype = String.prototype;
	var array_slice = ArrayPrototype.slice;
	var _toString = ObjectPrototype.toString;
	var isFunction = function(val) {
		return ObjectPrototype.toString.call(val) === "[object Function]";
	};
	var isArray = function isArray$1(obj) {
		return _toString.call(obj) === "[object Array]";
	};
	var isString = function isString$1(obj) {
		return _toString.call(obj) === "[object String]";
	};
	var supportsDescriptors = Object.defineProperty && function() {
		try {
			Object.defineProperty({}, "x", {});
			return true;
		} catch (e) {
			return false;
		}
	}();
	var defineProperty;
	if (supportsDescriptors) defineProperty = function(object, name, method, forceAssign) {
		if (!forceAssign && name in object) return;
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			writable: true,
			value: method
		});
	};
	else defineProperty = function(object, name, method, forceAssign) {
		if (!forceAssign && name in object) return;
		object[name] = method;
	};
	var defineProperties = function(object, map, forceAssign) {
		for (var name in map) if (ObjectPrototype.hasOwnProperty.call(map, name)) defineProperty(object, name, map[name], forceAssign);
	};
	var toObject = function(o) {
		if (o == null) throw new TypeError("can't convert " + o + " to object");
		return Object(o);
	};
	function toInteger(num) {
		var n = +num;
		if (n !== n) n = 0;
		else if (n !== 0 && n !== Infinity && n !== -Infinity) n = (n > 0 || -1) * Math.floor(Math.abs(n));
		return n;
	}
	function ToUint32(x) {
		return x >>> 0;
	}
	function Empty() {}
	defineProperties(FunctionPrototype, { bind: function bind(that) {
		var target = this;
		if (!isFunction(target)) throw new TypeError("Function.prototype.bind called on incompatible " + target);
		var args = array_slice.call(arguments, 1);
		var binder = function() {
			if (this instanceof bound) {
				var result = target.apply(this, args.concat(array_slice.call(arguments)));
				if (Object(result) === result) return result;
				return this;
			} else return target.apply(that, args.concat(array_slice.call(arguments)));
		};
		var boundLength = Math.max(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) boundArgs.push("$" + i);
		var bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this, arguments); }")(binder);
		if (target.prototype) {
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	} });
	defineProperties(Array, { isArray });
	var boxedString = Object("a");
	var splitString = boxedString[0] !== "a" || !(0 in boxedString);
	defineProperties(ArrayPrototype, { forEach: function forEach(fun) {
		var object = toObject(this), self$1 = splitString && isString(this) ? this.split("") : object, thisp = arguments[1], i = -1, length = self$1.length >>> 0;
		if (!isFunction(fun)) throw new TypeError();
		while (++i < length) if (i in self$1) fun.call(thisp, self$1[i], i, object);
	} }, !function properlyBoxed(method) {
		var properlyBoxesNonStrict = true;
		var properlyBoxesStrict = true;
		if (method) {
			method.call("foo", function(_, __, context) {
				if (typeof context !== "object") properlyBoxesNonStrict = false;
			});
			method.call([1], function() {
				properlyBoxesStrict = typeof this === "string";
			}, "x");
		}
		return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
	}(ArrayPrototype.forEach));
	defineProperties(ArrayPrototype, { indexOf: function indexOf(sought) {
		var self$1 = splitString && isString(this) ? this.split("") : toObject(this), length = self$1.length >>> 0;
		if (!length) return -1;
		var i = 0;
		if (arguments.length > 1) i = toInteger(arguments[1]);
		i = i >= 0 ? i : Math.max(0, length + i);
		for (; i < length; i++) if (i in self$1 && self$1[i] === sought) return i;
		return -1;
	} }, Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1);
	var string_split = StringPrototype.split;
	if ("ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || "tesst".split(/(s)*/)[1] === "t" || "test".split(/(?:)/, -1).length !== 4 || "".split(/.?/).length || ".".split(/()()/).length > 1) (function() {
		var compliantExecNpcg = /()??/.exec("")[1] === void 0;
		StringPrototype.split = function(separator, limit) {
			var string = this;
			if (separator === void 0 && limit === 0) return [];
			if (_toString.call(separator) !== "[object RegExp]") return string_split.call(this, separator, limit);
			var output = [], flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + (separator.sticky ? "y" : ""), lastLastIndex = 0, separator2, match, lastIndex, lastLength;
			separator = new RegExp(separator.source, flags + "g");
			string += "";
			if (!compliantExecNpcg) separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
			limit = limit === void 0 ? -1 >>> 0 : ToUint32(limit);
			while (match = separator.exec(string)) {
				lastIndex = match.index + match[0].length;
				if (lastIndex > lastLastIndex) {
					output.push(string.slice(lastLastIndex, match.index));
					if (!compliantExecNpcg && match.length > 1) match[0].replace(separator2, function() {
						for (var i = 1; i < arguments.length - 2; i++) if (arguments[i] === void 0) match[i] = void 0;
					});
					if (match.length > 1 && match.index < string.length) ArrayPrototype.push.apply(output, match.slice(1));
					lastLength = match[0].length;
					lastLastIndex = lastIndex;
					if (output.length >= limit) break;
				}
				if (separator.lastIndex === match.index) separator.lastIndex++;
			}
			if (lastLastIndex === string.length) {
				if (lastLength || !separator.test("")) output.push("");
			} else output.push(string.slice(lastLastIndex));
			return output.length > limit ? output.slice(0, limit) : output;
		};
	})();
	else if ("0".split(void 0, 0).length) StringPrototype.split = function split(separator, limit) {
		if (separator === void 0 && limit === 0) return [];
		return string_split.call(this, separator, limit);
	};
	var string_substr = StringPrototype.substr;
	defineProperties(StringPrototype, { substr: function substr(start, length) {
		return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);
	} }, "".substr && "0b".substr(-1) !== "b");
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/escape.js
var require_escape = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/escape.js": ((exports, module) => {
	var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g, extraLookup;
	var unrollLookup = function(escapable) {
		var i;
		var unrolled = {};
		var c = [];
		for (i = 0; i < 65536; i++) c.push(String.fromCharCode(i));
		escapable.lastIndex = 0;
		c.join("").replace(escapable, function(a) {
			unrolled[a] = "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
			return "";
		});
		escapable.lastIndex = 0;
		return unrolled;
	};
	module.exports = { quote: function(string) {
		var quoted = JSON.stringify(string);
		extraEscapable.lastIndex = 0;
		if (!extraEscapable.test(quoted)) return quoted;
		if (!extraLookup) extraLookup = unrollLookup(extraEscapable);
		return quoted.replace(extraEscapable, function(a) {
			return extraLookup[a];
		});
	} };
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/transport.js
var require_transport = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/transport.js": ((exports, module) => {
	var debug$5 = function() {};
	debug$5 = require_browser$1()("sockjs-client:utils:transport");
	module.exports = function(availableTransports) {
		return { filterToEnabled: function(transportsWhitelist, info) {
			var transports$1 = {
				main: [],
				facade: []
			};
			if (!transportsWhitelist) transportsWhitelist = [];
			else if (typeof transportsWhitelist === "string") transportsWhitelist = [transportsWhitelist];
			availableTransports.forEach(function(trans) {
				if (!trans) return;
				if (trans.transportName === "websocket" && info.websocket === false) {
					debug$5("disabled from server", "websocket");
					return;
				}
				if (transportsWhitelist.length && transportsWhitelist.indexOf(trans.transportName) === -1) {
					debug$5("not in whitelist", trans.transportName);
					return;
				}
				if (trans.enabled(info)) {
					debug$5("enabled", trans.transportName);
					transports$1.main.push(trans);
					if (trans.facadeTransport) transports$1.facade.push(trans.facadeTransport);
				} else debug$5("disabled", trans.transportName);
			});
			return transports$1;
		} };
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/utils/log.js
var require_log = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/utils/log.js": ((exports, module) => {
	var logObject = {};
	[
		"log",
		"debug",
		"warn"
	].forEach(function(level) {
		var levelExists;
		try {
			levelExists = global.console && global.console[level] && global.console[level].apply;
		} catch (e) {}
		logObject[level] = levelExists ? function() {
			return global.console[level].apply(global.console, arguments);
		} : level === "log" ? function() {} : logObject.log;
	});
	module.exports = logObject;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/event/event.js
var require_event = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/event/event.js": ((exports, module) => {
	function Event$3(eventType) {
		this.type = eventType;
	}
	Event$3.prototype.initEvent = function(eventType, canBubble, cancelable) {
		this.type = eventType;
		this.bubbles = canBubble;
		this.cancelable = cancelable;
		this.timeStamp = +/* @__PURE__ */ new Date();
		return this;
	};
	Event$3.prototype.stopPropagation = function() {};
	Event$3.prototype.preventDefault = function() {};
	Event$3.CAPTURING_PHASE = 1;
	Event$3.AT_TARGET = 2;
	Event$3.BUBBLING_PHASE = 3;
	module.exports = Event$3;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/location.js
var require_location = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/location.js": ((exports, module) => {
	module.exports = global.location || {
		origin: "http://localhost:80",
		protocol: "http:",
		host: "localhost",
		port: 80,
		href: "http://localhost/",
		hash: ""
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/event/close.js
var require_close = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/event/close.js": ((exports, module) => {
	var inherits$7 = require_inherits_browser(), Event$2 = require_event();
	function CloseEvent$1() {
		Event$2.call(this);
		this.initEvent("close", false, false);
		this.wasClean = false;
		this.code = 0;
		this.reason = "";
	}
	inherits$7(CloseEvent$1, Event$2);
	module.exports = CloseEvent$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/event/trans-message.js
var require_trans_message = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/event/trans-message.js": ((exports, module) => {
	var inherits$6 = require_inherits_browser(), Event$1 = require_event();
	function TransportMessageEvent$1(data) {
		Event$1.call(this);
		this.initEvent("message", false, false);
		this.data = data;
	}
	inherits$6(TransportMessageEvent$1, Event$1);
	module.exports = TransportMessageEvent$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/transport/sender/xhr-fake.js
var require_xhr_fake = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/transport/sender/xhr-fake.js": ((exports, module) => {
	var EventEmitter$4 = require_emitter().EventEmitter, inherits$5 = require_inherits_browser();
	function XHRFake$1() {
		var self$1 = this;
		EventEmitter$4.call(this);
		this.to = setTimeout(function() {
			self$1.emit("finish", 200, "{}");
		}, XHRFake$1.timeout);
	}
	inherits$5(XHRFake$1, EventEmitter$4);
	XHRFake$1.prototype.close = function() {
		clearTimeout(this.to);
	};
	XHRFake$1.timeout = 2e3;
	module.exports = XHRFake$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/info-ajax.js
var require_info_ajax = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/info-ajax.js": ((exports, module) => {
	var EventEmitter$3 = require_emitter().EventEmitter, inherits$4 = require_inherits_browser(), objectUtils$1 = require_object();
	var debug$4 = function() {};
	debug$4 = require_browser$1()("sockjs-client:info-ajax");
	function InfoAjax$2(url, AjaxObject) {
		EventEmitter$3.call(this);
		var self$1 = this;
		var t0 = +/* @__PURE__ */ new Date();
		this.xo = new AjaxObject("GET", url);
		this.xo.once("finish", function(status, text) {
			var info, rtt;
			if (status === 200) {
				rtt = +/* @__PURE__ */ new Date() - t0;
				if (text) try {
					info = JSON.parse(text);
				} catch (e) {
					debug$4("bad json", text);
				}
				if (!objectUtils$1.isObject(info)) info = {};
			}
			self$1.emit("finish", info, rtt);
			self$1.removeAllListeners();
		});
	}
	inherits$4(InfoAjax$2, EventEmitter$3);
	InfoAjax$2.prototype.close = function() {
		this.removeAllListeners();
		this.xo.close();
	};
	module.exports = InfoAjax$2;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/info-iframe-receiver.js
var require_info_iframe_receiver = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/info-iframe-receiver.js": ((exports, module) => {
	var inherits$3 = require_inherits_browser(), EventEmitter$2 = require_emitter().EventEmitter, XHRLocalObject = require_xhr_local(), InfoAjax$1 = require_info_ajax();
	function InfoReceiverIframe$1(transUrl) {
		var self$1 = this;
		EventEmitter$2.call(this);
		this.ir = new InfoAjax$1(transUrl, XHRLocalObject);
		this.ir.once("finish", function(info, rtt) {
			self$1.ir = null;
			self$1.emit("message", JSON.stringify([info, rtt]));
		});
	}
	inherits$3(InfoReceiverIframe$1, EventEmitter$2);
	InfoReceiverIframe$1.transportName = "iframe-info-receiver";
	InfoReceiverIframe$1.prototype.close = function() {
		if (this.ir) {
			this.ir.close();
			this.ir = null;
		}
		this.removeAllListeners();
	};
	module.exports = InfoReceiverIframe$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/info-iframe.js
var require_info_iframe = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/info-iframe.js": ((exports, module) => {
	var EventEmitter$1 = require_emitter().EventEmitter, inherits$2 = require_inherits_browser(), utils = require_event$1(), IframeTransport = require_iframe(), InfoReceiverIframe = require_info_iframe_receiver();
	var debug$3 = function() {};
	debug$3 = require_browser$1()("sockjs-client:info-iframe");
	function InfoIframe$1(baseUrl, url) {
		var self$1 = this;
		EventEmitter$1.call(this);
		var go = function() {
			var ifr = self$1.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);
			ifr.once("message", function(msg) {
				if (msg) {
					var d$1;
					try {
						d$1 = JSON.parse(msg);
					} catch (e) {
						debug$3("bad json", msg);
						self$1.emit("finish");
						self$1.close();
						return;
					}
					var info = d$1[0], rtt = d$1[1];
					self$1.emit("finish", info, rtt);
				}
				self$1.close();
			});
			ifr.once("close", function() {
				self$1.emit("finish");
				self$1.close();
			});
		};
		if (!global.document.body) utils.attachEvent("load", go);
		else go();
	}
	inherits$2(InfoIframe$1, EventEmitter$1);
	InfoIframe$1.enabled = function() {
		return IframeTransport.enabled();
	};
	InfoIframe$1.prototype.close = function() {
		if (this.ifr) this.ifr.close();
		this.removeAllListeners();
		this.ifr = null;
	};
	module.exports = InfoIframe$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/info-receiver.js
var require_info_receiver = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/info-receiver.js": ((exports, module) => {
	var EventEmitter = require_emitter().EventEmitter, inherits$1 = require_inherits_browser(), urlUtils$2 = require_url(), XDR = require_xdr(), XHRCors = require_xhr_cors(), XHRLocal = require_xhr_local(), XHRFake = require_xhr_fake(), InfoIframe = require_info_iframe(), InfoAjax = require_info_ajax();
	var debug$2 = function() {};
	debug$2 = require_browser$1()("sockjs-client:info-receiver");
	function InfoReceiver$1(baseUrl, urlInfo) {
		debug$2(baseUrl);
		var self$1 = this;
		EventEmitter.call(this);
		setTimeout(function() {
			self$1.doXhr(baseUrl, urlInfo);
		}, 0);
	}
	inherits$1(InfoReceiver$1, EventEmitter);
	InfoReceiver$1._getReceiver = function(baseUrl, url, urlInfo) {
		if (urlInfo.sameOrigin) return new InfoAjax(url, XHRLocal);
		if (XHRCors.enabled) return new InfoAjax(url, XHRCors);
		if (XDR.enabled && urlInfo.sameScheme) return new InfoAjax(url, XDR);
		if (InfoIframe.enabled()) return new InfoIframe(baseUrl, url);
		return new InfoAjax(url, XHRFake);
	};
	InfoReceiver$1.prototype.doXhr = function(baseUrl, urlInfo) {
		var self$1 = this, url = urlUtils$2.addPath(baseUrl, "/info");
		debug$2("doXhr", url);
		this.xo = InfoReceiver$1._getReceiver(baseUrl, url, urlInfo);
		this.timeoutRef = setTimeout(function() {
			debug$2("timeout");
			self$1._cleanup(false);
			self$1.emit("finish");
		}, InfoReceiver$1.timeout);
		this.xo.once("finish", function(info, rtt) {
			debug$2("finish", info, rtt);
			self$1._cleanup(true);
			self$1.emit("finish", info, rtt);
		});
	};
	InfoReceiver$1.prototype._cleanup = function(wasClean) {
		debug$2("_cleanup");
		clearTimeout(this.timeoutRef);
		this.timeoutRef = null;
		if (!wasClean && this.xo) this.xo.close();
		this.xo = null;
	};
	InfoReceiver$1.prototype.close = function() {
		debug$2("close");
		this.removeAllListeners();
		this._cleanup(false);
	};
	InfoReceiver$1.timeout = 8e3;
	module.exports = InfoReceiver$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/facade.js
var require_facade = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/facade.js": ((exports, module) => {
	var iframeUtils$1 = require_iframe$1();
	function FacadeJS$1(transport$1) {
		this._transport = transport$1;
		transport$1.on("message", this._transportMessage.bind(this));
		transport$1.on("close", this._transportClose.bind(this));
	}
	FacadeJS$1.prototype._transportClose = function(code, reason) {
		iframeUtils$1.postMessage("c", JSON.stringify([code, reason]));
	};
	FacadeJS$1.prototype._transportMessage = function(frame) {
		iframeUtils$1.postMessage("t", frame);
	};
	FacadeJS$1.prototype._send = function(data) {
		this._transport.send(data);
	};
	FacadeJS$1.prototype._close = function() {
		this._transport.close();
		this._transport.removeAllListeners();
	};
	module.exports = FacadeJS$1;
}) });

//#endregion
//#region node_modules/sockjs-client/lib/iframe-bootstrap.js
var require_iframe_bootstrap = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/iframe-bootstrap.js": ((exports, module) => {
	var urlUtils$1 = require_url(), eventUtils$1 = require_event$1(), FacadeJS = require_facade(), InfoIframeReceiver = require_info_iframe_receiver(), iframeUtils = require_iframe$1(), loc$1 = require_location();
	var debug$1 = function() {};
	debug$1 = require_browser$1()("sockjs-client:iframe-bootstrap");
	module.exports = function(SockJS$1, availableTransports) {
		var transportMap = {};
		availableTransports.forEach(function(at) {
			if (at.facadeTransport) transportMap[at.facadeTransport.transportName] = at.facadeTransport;
		});
		transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
		var parentOrigin;
		SockJS$1.bootstrap_iframe = function() {
			var facade;
			iframeUtils.currentWindowId = loc$1.hash.slice(1);
			var onMessage = function(e) {
				if (e.source !== parent) return;
				if (typeof parentOrigin === "undefined") parentOrigin = e.origin;
				if (e.origin !== parentOrigin) return;
				var iframeMessage;
				try {
					iframeMessage = JSON.parse(e.data);
				} catch (ignored) {
					debug$1("bad json", e.data);
					return;
				}
				if (iframeMessage.windowId !== iframeUtils.currentWindowId) return;
				switch (iframeMessage.type) {
					case "s":
						var p;
						try {
							p = JSON.parse(iframeMessage.data);
						} catch (ignored) {
							debug$1("bad json", iframeMessage.data);
							break;
						}
						var version$1 = p[0];
						var transport$1 = p[1];
						var transUrl = p[2];
						var baseUrl = p[3];
						debug$1(version$1, transport$1, transUrl, baseUrl);
						if (version$1 !== SockJS$1.version) throw new Error("Incompatible SockJS! Main site uses: \"" + version$1 + "\", the iframe: \"" + SockJS$1.version + "\".");
						if (!urlUtils$1.isOriginEqual(transUrl, loc$1.href) || !urlUtils$1.isOriginEqual(baseUrl, loc$1.href)) throw new Error("Can't connect to different domain from within an iframe. (" + loc$1.href + ", " + transUrl + ", " + baseUrl + ")");
						facade = new FacadeJS(new transportMap[transport$1](transUrl, baseUrl));
						break;
					case "m":
						facade._send(iframeMessage.data);
						break;
					case "c":
						if (facade) facade._close();
						facade = null;
						break;
				}
			};
			eventUtils$1.attachEvent("message", onMessage);
			iframeUtils.postMessage("s");
		};
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/main.js
var require_main = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/main.js": ((exports, module) => {
	require_shims();
	var URL = require_url_parse(), inherits = require_inherits_browser(), random = require_random(), escape = require_escape(), urlUtils = require_url(), eventUtils = require_event$1(), transport = require_transport(), objectUtils = require_object(), browser = require_browser(), log = require_log(), Event = require_event(), EventTarget = require_eventtarget(), loc = require_location(), CloseEvent = require_close(), TransportMessageEvent = require_trans_message(), InfoReceiver = require_info_receiver();
	var debug = function() {};
	debug = require_browser$1()("sockjs-client:main");
	var transports;
	function SockJS(url, protocols, options) {
		if (!(this instanceof SockJS)) return new SockJS(url, protocols, options);
		if (arguments.length < 1) throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
		EventTarget.call(this);
		this.readyState = SockJS.CONNECTING;
		this.extensions = "";
		this.protocol = "";
		options = options || {};
		if (options.protocols_whitelist) log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
		this._transportsWhitelist = options.transports;
		this._transportOptions = options.transportOptions || {};
		this._timeout = options.timeout || 0;
		var sessionId = options.sessionId || 8;
		if (typeof sessionId === "function") this._generateSessionId = sessionId;
		else if (typeof sessionId === "number") this._generateSessionId = function() {
			return random.string(sessionId);
		};
		else throw new TypeError("If sessionId is used in the options, it needs to be a number or a function.");
		this._server = options.server || random.numberString(1e3);
		var parsedUrl = new URL(url);
		if (!parsedUrl.host || !parsedUrl.protocol) throw new SyntaxError("The URL '" + url + "' is invalid");
		else if (parsedUrl.hash) throw new SyntaxError("The URL must not contain a fragment");
		else if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
		var secure = parsedUrl.protocol === "https:";
		if (loc.protocol === "https:" && !secure) {
			if (!urlUtils.isLoopbackAddr(parsedUrl.hostname)) throw new Error("SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS");
		}
		if (!protocols) protocols = [];
		else if (!Array.isArray(protocols)) protocols = [protocols];
		var sortedProtocols = protocols.sort();
		sortedProtocols.forEach(function(proto, i) {
			if (!proto) throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
			if (i < sortedProtocols.length - 1 && proto === sortedProtocols[i + 1]) throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
		});
		var o = urlUtils.getOrigin(loc.href);
		this._origin = o ? o.toLowerCase() : null;
		parsedUrl.set("pathname", parsedUrl.pathname.replace(/\/+$/, ""));
		this.url = parsedUrl.href;
		debug("using url", this.url);
		this._urlInfo = {
			nullOrigin: !browser.hasDomain(),
			sameOrigin: urlUtils.isOriginEqual(this.url, loc.href),
			sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
		};
		this._ir = new InfoReceiver(this.url, this._urlInfo);
		this._ir.once("finish", this._receiveInfo.bind(this));
	}
	inherits(SockJS, EventTarget);
	function userSetCode(code) {
		return code === 1e3 || code >= 3e3 && code <= 4999;
	}
	SockJS.prototype.close = function(code, reason) {
		if (code && !userSetCode(code)) throw new Error("InvalidAccessError: Invalid code");
		if (reason && reason.length > 123) throw new SyntaxError("reason argument has an invalid length");
		if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) return;
		this._close(code || 1e3, reason || "Normal closure", true);
	};
	SockJS.prototype.send = function(data) {
		if (typeof data !== "string") data = "" + data;
		if (this.readyState === SockJS.CONNECTING) throw new Error("InvalidStateError: The connection has not been established yet");
		if (this.readyState !== SockJS.OPEN) return;
		this._transport.send(escape.quote(data));
	};
	SockJS.version = require_version();
	SockJS.CONNECTING = 0;
	SockJS.OPEN = 1;
	SockJS.CLOSING = 2;
	SockJS.CLOSED = 3;
	SockJS.prototype._receiveInfo = function(info, rtt) {
		debug("_receiveInfo", rtt);
		this._ir = null;
		if (!info) {
			this._close(1002, "Cannot connect to server");
			return;
		}
		this._rto = this.countRTO(rtt);
		this._transUrl = info.base_url ? info.base_url : this.url;
		info = objectUtils.extend(info, this._urlInfo);
		debug("info", info);
		this._transports = transports.filterToEnabled(this._transportsWhitelist, info).main;
		debug(this._transports.length + " enabled transports");
		this._connect();
	};
	SockJS.prototype._connect = function() {
		for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
			debug("attempt", Transport.transportName);
			if (Transport.needBody) {
				if (!global.document.body || typeof global.document.readyState !== "undefined" && global.document.readyState !== "complete" && global.document.readyState !== "interactive") {
					debug("waiting for body");
					this._transports.unshift(Transport);
					eventUtils.attachEvent("load", this._connect.bind(this));
					return;
				}
			}
			var timeoutMs = Math.max(this._timeout, this._rto * Transport.roundTrips || 5e3);
			this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
			debug("using timeout", timeoutMs);
			var transportUrl = urlUtils.addPath(this._transUrl, "/" + this._server + "/" + this._generateSessionId());
			var options = this._transportOptions[Transport.transportName];
			debug("transport url", transportUrl);
			var transportObj = new Transport(transportUrl, this._transUrl, options);
			transportObj.on("message", this._transportMessage.bind(this));
			transportObj.once("close", this._transportClose.bind(this));
			transportObj.transportName = Transport.transportName;
			this._transport = transportObj;
			return;
		}
		this._close(2e3, "All transports failed", false);
	};
	SockJS.prototype._transportTimeout = function() {
		debug("_transportTimeout");
		if (this.readyState === SockJS.CONNECTING) {
			if (this._transport) this._transport.close();
			this._transportClose(2007, "Transport timed out");
		}
	};
	SockJS.prototype._transportMessage = function(msg) {
		debug("_transportMessage", msg);
		var self$1 = this, type = msg.slice(0, 1), content = msg.slice(1), payload;
		switch (type) {
			case "o":
				this._open();
				return;
			case "h":
				this.dispatchEvent(new Event("heartbeat"));
				debug("heartbeat", this.transport);
				return;
		}
		if (content) try {
			payload = JSON.parse(content);
		} catch (e) {
			debug("bad json", content);
		}
		if (typeof payload === "undefined") {
			debug("empty payload", content);
			return;
		}
		switch (type) {
			case "a":
				if (Array.isArray(payload)) payload.forEach(function(p) {
					debug("message", self$1.transport, p);
					self$1.dispatchEvent(new TransportMessageEvent(p));
				});
				break;
			case "m":
				debug("message", this.transport, payload);
				this.dispatchEvent(new TransportMessageEvent(payload));
				break;
			case "c":
				if (Array.isArray(payload) && payload.length === 2) this._close(payload[0], payload[1], true);
				break;
		}
	};
	SockJS.prototype._transportClose = function(code, reason) {
		debug("_transportClose", this.transport, code, reason);
		if (this._transport) {
			this._transport.removeAllListeners();
			this._transport = null;
			this.transport = null;
		}
		if (!userSetCode(code) && code !== 2e3 && this.readyState === SockJS.CONNECTING) {
			this._connect();
			return;
		}
		this._close(code, reason);
	};
	SockJS.prototype._open = function() {
		debug("_open", this._transport && this._transport.transportName, this.readyState);
		if (this.readyState === SockJS.CONNECTING) {
			if (this._transportTimeoutId) {
				clearTimeout(this._transportTimeoutId);
				this._transportTimeoutId = null;
			}
			this.readyState = SockJS.OPEN;
			this.transport = this._transport.transportName;
			this.dispatchEvent(new Event("open"));
			debug("connected", this.transport);
		} else this._close(1006, "Server lost session");
	};
	SockJS.prototype._close = function(code, reason, wasClean) {
		debug("_close", this.transport, code, reason, wasClean, this.readyState);
		var forceFail = false;
		if (this._ir) {
			forceFail = true;
			this._ir.close();
			this._ir = null;
		}
		if (this._transport) {
			this._transport.close();
			this._transport = null;
			this.transport = null;
		}
		if (this.readyState === SockJS.CLOSED) throw new Error("InvalidStateError: SockJS has already been closed");
		this.readyState = SockJS.CLOSING;
		setTimeout(function() {
			this.readyState = SockJS.CLOSED;
			if (forceFail) this.dispatchEvent(new Event("error"));
			var e = new CloseEvent("close");
			e.wasClean = wasClean || false;
			e.code = code || 1e3;
			e.reason = reason;
			this.dispatchEvent(e);
			this.onmessage = this.onclose = this.onerror = null;
			debug("disconnected");
		}.bind(this), 0);
	};
	SockJS.prototype.countRTO = function(rtt) {
		if (rtt > 100) return 4 * rtt;
		return 300 + rtt;
	};
	module.exports = function(availableTransports) {
		transports = transport(availableTransports);
		require_iframe_bootstrap()(SockJS, availableTransports);
		return SockJS;
	};
}) });

//#endregion
//#region node_modules/sockjs-client/lib/entry.js
var require_entry = /* @__PURE__ */ __commonJS({ "node_modules/sockjs-client/lib/entry.js": ((exports, module) => {
	var transportList = require_transport_list();
	module.exports = require_main()(transportList);
	if ("_sockjs_onload" in global) setTimeout(global._sockjs_onload, 1);
}) });

//#endregion
export default require_entry();

//# sourceMappingURL=sockjs-client.js.map